---
title: "MHW_eilat_DBG"
author: "Dan Bez Golanski"
date: "2023-11-01"
output: html_document
editor_options: 
  chunk_output_type: console
---
# load packages
```{r warning=FALSE}
library(tidyverse)
library(patchwork)
library(lubridate)
library(suncalc)
library(openxlsx)
library(ggplot2)
library(mgcv)
library(gratia)
library(DataExplorer)
library(ggeffects) # Plot gam effects
library(rfishbase)
library(ggpmisc) # plotting linear models with equations
library(svglite) # save svg with ggplot
library(glatos) # for collision estimating
```


# Functions
```{r}
Filter_Fish <- function(fish_ids,raw_fish_df) { 
filter_fish <- raw_fish_df %>% filter(fish_id %in% fish_ids)
filter_fish <- filter_fish %>%
  arrange(fish_id,real_datetime)
return(filter_fish)
}

#need to have fish_id and real_datetime columns before using 
Compute_sampling_freq <- function(filter_fish,valuble_fish) {
  filter_fish$date <- as.Date(filter_fish$real_datetime,format = "%d/%m/%y")
  samp_freq_df <- data.frame(fish_id=integer(),
                           date=POSIXct(),
                           mean_freq_min=double(),
                           median_freq_min=double(),
                           n=integer())
for (fish in valuble_fish) {
  temp_fish <- filter_fish %>% filter(fish_id==fish)
  for (day in unique(temp_fish$date)) {
    temp_day <- temp_fish %>% filter(date==day)
    freq_vector <- c()
    for (row_num in 2:dim(temp_day)[1]) {
      freq_vector[row_num-1] <-   
        difftime(temp_day$real_datetime[row_num],temp_day$real_datetime[row_num-1],units = "mins")
    }
    temp_samp_df <- data.frame(fish_id=fish,
                                 date=day,
                                 mean_freq_min = mean(freq_vector),
                                 median_freq_min= median(freq_vector),
                                 n=length(freq_vector))
    samp_freq_df <- rbind(samp_freq_df,temp_samp_df)
  }
  
}
samp_freq_df$date <- as.Date(samp_freq_df$date,origin = "1970-01-01")
rm(temp_day,temp_fish,temp_samp_df)
return(samp_freq_df)
}

Before_After_MHW <- function(filter_fish,heatwave_date_start,heatwave_date_end,Continous = F) {
# filter_fish$real_datetime <- parse_date_time(filter_fish$real_datetime, orders = "ymd HMS")
heatwave_date_start <- parse_date_time(heatwave_date_start,orders = "ymd")
heatwave_date_end <- parse_date_time(heatwave_date_end,orders = "ymd")
filter_fish$Before_After <- ifelse(filter_fish$real_datetime < heatwave_date_start,"Before",ifelse(filter_fish$real_datetime > heatwave_date_end,"After","MHW"))
if(Continous)
{
  for (row_num in 1:dim(filter_fish)[1]) {
    if(filter_fish$Before_After[row_num]=="Before")
    {
      filter_fish$Before_After_continiuos[row_num] <- 
        difftime(filter_fish$real_datetime[row_num],heatwave_date_start,units = "days")
    } else if(filter_fish$Before_After[row_num]=="After")
    {
      filter_fish$Before_After_continiuos[row_num] <- 
        difftime(filter_fish$real_datetime[row_num],heatwave_date_end,units = "days")
    }
    else
    {
      filter_fish$Before_After_continiuos[row_num] <- 0
    }
  }
}
return(filter_fish)
}

Add_Day_Period <- function(MHW_Data) {
#Eilat coordinates
date_sun_df <- data.frame(date=as.Date(unique(MHW_Data$date)),
                          lat=29.538417,
                          lon=34.954417)
date_sun_df <- getSunlightTimes(data = date_sun_df, keep = 
                                 c("sunriseEnd","sunsetStart","night","nightEnd"),tz="Asia/Jerusalem")
# In order to ease the dealing with date and time after
date_sun_df[,4:7] <- force_tz(date_sun_df[,4:7],tz="UTC")
for (date_num in date_sun_df$date) {
  temp_date <- MHW_Data %>% filter(date==date_num)
  temp_sun <- date_sun_df %>% filter(date==date_num)
  temp_date$Period <- ifelse(temp_date$real_datetime>temp_sun$sunriseEnd[1] & 
                                     temp_date$real_datetime<temp_sun$sunsetStart[1],"Day",
                                   ifelse(temp_date$real_datetime>temp_sun$nightEnd[1] & 
                                     temp_date$real_datetime<temp_sun$sunriseEnd[1],"Dawn",
                                     ifelse(temp_date$real_datetime>temp_sun$sunsetStart[1] & 
                                     temp_date$real_datetime<temp_sun$night[1],"Dusk","Night")))
  MHW_Data$Period[MHW_Data$date==date_num] <- temp_date$Period 
  }
return(MHW_Data)
}

conditional_merge <- function(df1, df2, by_cols) {
  if (nrow(df1) == 0) {
    return(df2)
  } else if (nrow(df2) == 0) {
    return(df1)
  } else {
    return(merge(df1, df2, by = by_cols,all= T))
  }
  
}

Fill_In_temp_sum_heat_wave <- function(sum_heat_wave_colnames, temp_sum_heat_wave) {
  missing_col_names <- sum_heat_wave_colnames[which(!(sum_heat_wave_colnames %in% colnames(temp_sum_heat_wave)))]
  for (name in missing_col_names) {
     temp_sum_heat_wave[,name] <- NA
  }
  return(temp_sum_heat_wave)
  
}

time_to_decimal <- function(time) {
  hours <- as.numeric(format(time, "%H"))
  minutes <- as.numeric(format(time, "%M"))
  seconds <- as.numeric(format(time, "%S"))
  decimal_time <- hours + minutes / 60 + seconds / 3600
  return(decimal_time)
}

Plot_with_species <- function(mod,my_data)
{
  
# Ensure Serial_fish_id is correctly paired with species
unique_fish <- my_data %>%
  select(Serial_fish_id, species) %>%
  distinct()

# Create new data with appropriate Serial_fish_id for each species
new_data <- expand.grid(
  DecimalTimeOfDay = seq(min(my_data$DecimalTimeOfDay), max(my_data$DecimalTimeOfDay), length.out = 100),
  Before_After = unique(my_data$Before_After)
) %>%
  # Expand for each individual fish with its corresponding species
  crossing(unique_fish)

# Get predictions while respecting fish ID and species
preds <- predict(mod, newdata = new_data, type = "response", se.fit = TRUE)
new_data$pred <- preds$fit
new_data$se <- preds$se.fit

# Average predictions over individuals within each species & Before_After
agg_data <- new_data %>%
  group_by(DecimalTimeOfDay, species, Before_After) %>%
  summarise(
    pred = mean(pred),
    se = mean(se),
    .groups = "drop"
  )

# Plot smooth curves
ggplot(agg_data, aes(x = DecimalTimeOfDay, y = pred, color = Before_After)) +
  geom_line(size = 1) +
  geom_ribbon(aes(ymin = pred - 1.96 * se, ymax = pred + 1.96 * se, fill = Before_After), alpha = 0.2) +
  facet_wrap(~ species,scales = "free") +
  scale_color_manual(values = c("MHW" = "red", "After" = "green", "Before" = "blue")) +
  scale_fill_manual(values = c("MHW" = "red", "After" = "green", "Before" = "blue")) +
  theme_minimal() +
  labs(
    x = "Time of Day",
    title = "Smooth Effects by Species and Before/After"
  ) +
  theme(legend.position = "bottom")
  # 
}

Plot_with_individuals <- function(mod,my_data)
{
  
# Create new data with appropriate Serial_fish_id for each species
new_data <- expand.grid(
  DecimalTimeOfDay = seq(min(my_data$DecimalTimeOfDay), max(my_data$DecimalTimeOfDay), length.out = 100),
  Serial_fish_id= unique(my_data$Serial_fish_id),
  Before_After = unique(my_data$Before_After),
  Serial_fish_id="no fish"
) 
# Get predictions while respecting fish ID and species
preds <- predict(mod, newdata = new_data, type = "response", se.fit = TRUE,exclude = "s(Serial_fish_id)")
new_data$pred <- preds$fit
new_data$se <- preds$se.fit

# Plot smooth curves
ggplot(new_data, aes(x = DecimalTimeOfDay, y = pred, color = Before_After)) +
  geom_line(size = 1) +
  geom_ribbon(aes(ymin = pred - 1.96 * se, ymax = pred + 1.96 * se, fill = Before_After), alpha = 0.2) +
  facet_wrap(~ Serial_fish_id,scales = "free") +
  scale_color_manual(values = c("MHW" = "red", "After" = "green", "Before" = "blue")) +
  scale_fill_manual(values = c("MHW" = "red", "After" = "green", "Before" = "blue")) +
  theme_minimal() +
  labs(
    x = "Time of Day",
    title = "Smooth Effects by individuals and Before/After"
  ) +
  theme(legend.position = "bottom")
  
}

get_MHW_fish_df <- function(MHW_def) {
  MHWs_Eilat <- MHW_def

MHWs_fish_data <- data.frame()
for (event in 1:dim(MHWs_Eilat)[1]) {
  #get the fish id relates to the specific MHWs
  fish_ids <- unlist(strsplit(MHWs_Eilat$Fish_IDs, ", ")[[event]])
  #Check if there are any fish
  if(length(na.omit(fish_ids))>0)
  {
    #filter the fish to the widest period, add before.after and period of day
    #using the right database
    filter_fish <- Filter_Fish(fish_ids,combined_parrotfish_df)  
    ####### takes the longer timespan, 3 times before and after the MHW #####
    MHW_Data <- filter_fish %>% filter(date>= MHWs_Eilat$start_1.5[event] & date<= MHWs_Eilat$end_1.5[event])
    MHW_Data <- Before_After_MHW(MHW_Data,MHWs_Eilat$date_start[event], MHWs_Eilat$date_end[event])
    
    #remove column of fish ids
    names(MHWs_Eilat) <- make.names(names(MHWs_Eilat), unique = TRUE)
    temp_MHWs_Eilat <- MHWs_Eilat %>% select(-Fish_IDs)
    MHW_Data <- MHW_Data %>% arrange(fish_id,real_datetime)
    MHW_Data$Serial <- MHWs_Eilat$Serial[event]
    MHW_Data <- merge(MHW_Data,temp_MHWs_Eilat,by="Serial")
    MHWs_fish_data <- rbind(MHWs_fish_data,MHW_Data)  
  }
}

# Create a column with the time of the day
MHWs_fish_data$TimeOfDay <- as.POSIXct(format(MHWs_fish_data$real_datetime,format = "%H:%M:%S"),format = "%H:%M:%S")

# Convert time of day to decimal format for modeling
MHWs_fish_data$DecimalTimeOfDay <- time_to_decimal(MHWs_fish_data$TimeOfDay) 

# Convert species column to factor
MHWs_fish_data$species <-as.factor(MHWs_fish_data$species) 

MHWs_fish_data$Before_After <- as.factor(MHWs_fish_data$Before_After)

# Ensure date columns are in POSIXct format
MHWs_Eilat$date_start <- as.POSIXct(MHWs_Eilat$date_start)
MHWs_Eilat$date_end <- as.POSIXct(MHWs_Eilat$date_end)

MHWs_fish_data$Before_After <- factor(MHWs_fish_data$Before_After,levels = c("Before", "MHW", "After"))
MHWs_fish_data$Before_After <- relevel(MHWs_fish_data$Before_After,ref="Before")
return(MHWs_fish_data)
}

get_distance_metrics <- function(MHW_def) {
  MHW_daily_distance_df <- get_MHW_fish_df(MHWs_Eilat) 
MHW_daily_distance_df <- MHW_daily_distance_df %>%
  mutate(hour = hour(real_datetime)) %>%     # Extract hour
  Add_Day_Period(.) %>% 
  arrange(fish_id,real_datetime) %>%
  mutate(solar_date = case_when(
      Period == "Night" & hour < 12 ~ date - 1,  # Early Night (after midnight) â†’ subtract 1 day
      TRUE ~ date  # Otherwise keep the same
    )) %>% 
  relocate(hour,Period,solar_date,.after = date) %>% 
  ungroup()
  MHW_daily_distance_df <- MHW_daily_distance_df %>%
  group_by(Serial,fish_id, solar_date) %>%
  filter(!is.na(distance_shore)) %>%
  summarise(
    n = n(),
    # Max daily displacement: median of the top 10% - median of the bottom 10%
    max_daily_displacement = {
      filter_distances <- distance_shore[Period == "Day"]
      filter_distances <- sort(distance_shore, na.last = NA)
        n <- length(filter_distances)
      ifelse(n>10,
             {
               
              top_10_percent <- filter_distances[ceiling(0.9 * n):n]
              bottom_10_percent <- filter_distances[1:floor(0.1 * n)]
              abs(median(top_10_percent, na.rm = TRUE) - 
                    median(bottom_10_percent,na.rm = TRUE))         
              }
      ,NA)
      
    },

    # Night counts (hour between 22:00 and 4:00)
    night_count = sum(hour >= 22 | hour < 4),

    # Night displacement for 5
    night_median_6 = if_else(
      night_count > 6,
      median(distance_shore[hour >= 22 | hour < 4], na.rm = TRUE),
      NA_real_
    ),
    night_displacement_6 =
      {
      filter_distances <- distance_shore[Period == "Day" | Period == "Dusk" | 
                                           Period =="Dawn"]
      sorted_distances <- sort(filter_distances, na.last = NA)
      n <- length(sorted_distances)
      top_10_percent <- sorted_distances[ceiling(0.9 * n):n]
      abs(top_10_percent - night_median_6)
      },
    # Additional columns (unchanged)
    Serial=first(Serial),
    fish_id=first(fish_id),
    size = first(size),
    species = first(species),
    Before_After = first(Before_After),
    date_start = first(date_start),
    date_peak = first(date_peak),
    date_end = first(date_end),
    duration = first(duration),
    intensity_mean = first(intensity_mean),
    intensity_max = first(intensity_max),
    intensity_var = first(intensity_var),
    intensity_cumulative = first(intensity_cumulative),
    intensity_mean_relThresh = first(intensity_mean_relThresh),
    intensity_max_relThresh = first(intensity_max_relThresh),
    intensity_var_relThresh = first(intensity_var_relThresh),
    intensity_mean_abs = first(intensity_mean_abs),
    intensity_max_abs = first(intensity_max_abs),
    intensity_var_abs = first(intensity_var_abs),
    rate_onset = first(rate_onset),
    rate_decline = first(rate_decline),
    # Category = first(Category),
    start_1.5 = first(start_1.5),
    reliability_level = first(reliabaility.level),
    end_1.5 = first(end_1.5),
    reliability_level_1 = first(reliabaility.level.1),
    start_3 = first(start_3),
    reliability_level_2 = first(reliabaility.level.2),
    end_3 = first(end_3),
    reliability_level_3 = first(reliabaility.level.3)
  ) %>%
  ungroup()%>%
  distinct(Serial,fish_id, solar_date, .keep_all = TRUE)  # Remove duplicates explicitly)
  # Calculate the mean for each serial_fish_id and Before_After
MHW_disp_summary <- MHW_daily_distance_df %>%
  group_by(Serial,fish_id,Before_After) %>%
  summarise(
    mean_disp_max = mean(max_daily_displacement, na.rm = TRUE),
    sd_disp_max = sd(max_daily_displacement, na.rm = TRUE),  # Standard deviation
    disp_max_days = sum(!is.na(max_daily_displacement)),  # Number of non-NA values
    mean_disp_night = mean(night_displacement_6, na.rm = TRUE),
    sd_disp_night = sd(night_displacement_6, na.rm = TRUE),
    disp_night_days = sum(!is.na(night_displacement_6)),
    .groups = 'drop')

MHW_disp_comparison <- MHW_disp_summary %>%
  select(Serial,fish_id,Before_After,mean_disp_max) %>% 
  pivot_wider(names_from = Before_After, values_from = mean_disp_max) %>%
  mutate(
    delta_MHW_Before = abs(`MHW` - `Before`),  # MHW - Before
    delta_After_Before = abs(`After` - `Before`),  # After - Before
    log_MHW_Before = ifelse(is.finite(log(`MHW` / `Before`)), log(`MHW` / `Before`), NA_real_),
    log_After_Before = ifelse(is.finite(log(`After` / `Before`)), log(`After` / `Before`), NA_real_)
    )
    return(list(sum_disp = MHW_disp_summary,comparison_disp = 
                  MHW_disp_comparison))
}


models_comparison <- function(models)
{
  model_names <- paste0("Model_", seq_along(models))
   comparison <- tibble(
    Model_number = model_names,  
    model_formula = sapply(models, function(model) paste(deparse(formula(model)), collapse = "")),
    AIC = sapply(models, AIC),
    BIC = sapply(models, BIC),
    LogLik = sapply(models, logLik),
    Deviance = sapply(models, function(m) m$deviance),
    R2 = sapply(models, function(m) summary(m)$r.sq)
  )
  # Order by AIC (ascending, best model first)
  comparison <- comparison %>% arrange(AIC)
  
  # Compute Î”AIC (relative to best model)
  comparison <- comparison %>%
    mutate(Delta_AIC = AIC - min(AIC, na.rm = TRUE))
  
  # Compute Î”RÂ² (relative to best model)
  max_r2 <- max(comparison$R2, na.rm = TRUE)
  comparison <- comparison %>%
    mutate(Delta_R2 = max_r2 - R2)
  
  print(comparison)
  return(comparison)
}

# -------------------------------
# Function: run_model_safely()
# Purpose: Runs a GAM model safely, catching errors and warnings.
# If a model fails to converge, return NULL
# -------------------------------
run_model_safely <- function(formula, data, family) {
  model <- tryCatch(
    {
      bam(formula, data = data, method = "REML", family = family, knots= list(DecimalTimeOfDay=c(-0.5,24.5)))
    },
    error = function(e) {
      message("âŒ Model failed to run: ", conditionMessage(e))
      return(NULL)  # Return NULL for failed models
    },
    warning = function(w) {
      message("âš ï¸ Warning: ", conditionMessage(w), "Model: ", formula)
      return(NULL)  # Treat warnings as failures
    }
  )
  
  # If model runs but does not converge, remove it
  if (!is.null(model) && !model$converged) {
    message("âš ï¸ Model did not converge and will be removed.")
    return(NULL)
  }
  
  return(model)  # Return successfully fitted model
}

# -------------------------------
# Function: automate_model_selection()
# Purpose: Automates the process of model selection in 3 stages:
#    1ï¸âƒ£ Fit models without MHW effect
#    2ï¸âƒ£ Add MHW effect (smooth or fixed)
#    3ï¸âƒ£ Add species effect
# Returns: 
#    âœ… The best final model
#    âœ… A list of all models created along the way
# -------------------------------
automate_model_selection <- function(data, response_var, family) {
  
  # Ensure the response variable exists in the dataset
  if (!response_var %in% names(data)) {
    stop("âŒ Response variable not found in the dataset!")
  }

  all_models <- list()  # List to store all models created
  
  # -------------------------------------------
  # 1ï¸âƒ£ Step 1: Fit initial models (without MHW effect)
  # -------------------------------------------
  model_formulas_no_MHW <- list(
    as.formula(paste(response_var, "~ s(DecimalTimeOfDay, bs = 'cc') + s(Serial_fish_id, k=12, bs='re')")), # Global with individual fish random  intercept effect
    as.formula(paste(response_var, "~ s(DecimalTimeOfDay, bs = 'cc', m = 2) +s(DecimalTimeOfDay, Serial_fish_id,bs='fs',k=12, m = 1) ")),# GS - global with random intecept and slope for individual fish
    as.formula(paste(response_var, "~ s(DecimalTimeOfDay, Serial_fish_id,bs='fs',k=12)"))) # S - random slopes and intercept per fish
  
  models_no_MHW <- lapply(model_formulas_no_MHW, run_model_safely, data = data, family = family)
  models_no_MHW <- Filter(Negate(is.null), models_no_MHW)  # Remove NULL models

  if (length(models_no_MHW) == 0) stop("âŒ No models converged in the first step!")

  all_models[["no_MHW"]] <- models_no_MHW  # Store models
  
  # Select the best model (the model object, not just formula)
  best_no_MHW <- models_no_MHW[[which.min(sapply(models_no_MHW, AIC))]]
  message("ðŸ† Best model without MHW: ", deparse(formula(best_no_MHW)))
  
  # -------------------------------------------
  #  Step 2: Add species effect
  # -------------------------------------------
  # model_formulas_with_species <- list(
  #   formula(best_no_MHW),
  #   update.formula(formula(best_no_MHW), . ~ . + species + s(DecimalTimeOfDay,by = species, bs = 'cc'))
  # )
  # 
  # models_with_species <- lapply(model_formulas_with_species, run_model_safely, data = data, family = family)
  # models_with_species <- Filter(Negate(is.null), models_with_species)  # Remove NULL models
  # 
  # if (length(models_with_species) == 0) {
  #   message("âš ï¸ No models converged with species effect. Returning best model without species.")
  #   return(list(best_model = best_no_MHW, all_models = all_models))
  # }
  # 
  # all_models[["with_species"]] <- models_with_species
  # 
  # # Select the best model with or without species
  # best_with_species <- models_with_species[[which.min(sapply(models_with_species, AIC))]]
  # message("ðŸ† Best model with species: ", deparse(formula(best_with_species)))
  
  # -------------------------------------------
  #  Step 3: Add MHW effect 
  # -------------------------------------------
  model_formulas_with_MHW <- list(
    formula(best_no_MHW),
    update.formula(formula(best_no_MHW), . ~ . + Before_After),
    as.formula(paste(response_var, "~ Before_After + s(DecimalTimeOfDay, Serial_fish_id,bs='fs',by=Before_After,k=12)")),# S - random slopes and intercept per fish and MHW effect on intercept and on smooth
    as.formula(paste(response_var, "~ Before_After + s(DecimalTimeOfDay, by = Before_After, bs = 'cc') +s(DecimalTimeOfDay, Serial_fish_id, bs = 'fs', k = 12)"))) 

  models_with_MHW <- lapply(model_formulas_with_MHW, run_model_safely, data = data, family = family)
  models_with_MHW <- Filter(Negate(is.null), models_with_MHW)  # Remove NULL models
  
  if (length(models_with_MHW) == 0) stop("âŒ No models converged with MHW effect!")
  
  all_models[["with_MHW"]] <- models_with_MHW
  
  # Select the best model with MHW (the model object, not just formula)
  best_final <- models_with_MHW[[which.min(sapply(models_with_MHW, AIC))]]
  message("ðŸ† Best final model with MHW: ", deparse(formula(best_final)))
  
  # Combine all lists in 'all_models' into one list
  combined_models <- c(all_models$no_MHW, all_models$with_MHW)
  
  # Run model comparison on unique models
  comparison_table <- models_comparison(combined_models)
  
  # Return the best model object and the comparison table
  return(list(best_model = best_final, all_models = all_models, comparison_table = comparison_table,data = data))
}





```

# Planning design - acoustic & fish
## Collision planning and estimating
```{r}
# 6 seconds burst duration - according to thelma
calc_prob1 <- calc_collision_prob(delayRng = c(120,240),burstDur = 6,maxTags = 15,nTrans=10000 )
calc_prob2 <- calc_collision_prob(delayRng = c(150,210),burstDur = 6,maxTags = 15,nTrans=10000 )
# 3 seconds burst duration
calc_prob3 <- calc_collision_prob(delayRng = c(150,210),burstDur = 3,maxTags = 15,nTrans=10000 )
calc_prob4 <- calc_collision_prob(delayRng = c(120,240),burstDur = 3,maxTags = 15,nTrans=10000 )
# Detection probability plots
plot(med ~ nTags,
  data = calc_prob1, type = "p", pch = 20, ylim = c(0, 1),
  xlab = "# of transmitters within range", ylab = "Probability of detection"
)
plot(med ~ nTags,
  data = calc_prob2, type = "p", pch = 20, ylim = c(0, 1),
  xlab = "# of transmitters within range", ylab = "Probability of detection"
)
plot(med ~ nTags,
  data = calc_prob3, type = "p", pch = 20, ylim = c(0, 1),
  xlab = "# of transmitters within range", ylab = "Probability of detection"
)
plot(med ~ nTags,
  data = calc_prob4, type = "p", pch = 20, ylim = c(0, 1),
  xlab = "# of transmitters within range", ylab = "Probability of detection"
)
# Collisions probability plots
plot((1 - med) ~ nTags,
  data = calc_prob1, type = "p", pch = 20, ylim = c(0, 1),
  xlab = "# of transmitters within range", ylab = "Probability of collision"
)

```


## Bioblitz analyze for NPA permit
```{r}
bioblitz_df <- read.xlsx("D:/Dan/Research/Projects/MHWs/Mediterranean/Bioblitz Data/Biob_data_2015-2023_all_data.xlsx",sheet = "Biob_data_2015-2023_Inc_Fall_20")
study_species <- c("Diplodus.sargus","Siganus.luridus", "Siganus.rivulatus", "Epinephelus.marginatus")

# Filter the data for Spring 2023
bioblitz_df <- bioblitz_df %>% 
  filter(year == 2023 & season == "Spring")

# Summarize abundance by species
bioblitz_summary <- bioblitz_df %>% 
  group_by(species) %>% 
  summarise(total_abundance = sum(abundance)) %>%
  mutate(relative_abundance = total_abundance / sum(total_abundance)) %>%
  arrange(desc(relative_abundance)) 

# Add rank and ensure species is a factor
bioblitz_summary <- bioblitz_summary %>%
  mutate(rank_abundance = row_number(),
         species = factor(species, levels = species),
         is_study_species = ifelse(species %in% study_species, "Study Species", "Other"))

# Plot with highlighted bars
ggplot(bioblitz_summary, aes(x = species, y = relative_abundance, fill = is_study_species)) + 
  geom_bar(stat = "identity") + 
  scale_fill_manual(values = c("Study Species" = "red", "Other" = "grey")) +
  labs(x = "Species", y = "Relative Abundance", title = "Relative Abundance by Species") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Filter to only study species
bioblitz_summary_location <- bioblitz_df %>% filter(species %in% study_species)

#Plot size histograms
ggplot(bioblitz_summary_location, aes(y = length, fill = species)) +
  geom_histogram() + 
  facet_wrap(~ species, scales = "free") +
  coord_flip()+
  labs(y = "Length (cm)") +
  scale_fill_manual(values = c("Diplodus.sargus" = "blue", 
                               "Siganus.luridus" = "green", 
                               "Siganus.rivulatus" = "purple", 
                               "Epinephelus.marginatus" = "orange")) +
  scale_y_continuous(breaks = seq(0, max(bioblitz_summary_location$length, na.rm = TRUE), by = 3)) +
  theme_minimal() +
  theme(axis.text.x = element_text(hjust = 1))
  
# Summarize abundance by species and location  
bioblitz_summary_location <- bioblitz_summary_location %>% 
  group_by(location, species) %>% 
  summarise(total_abundance = sum(abundance), .groups = "drop") %>%
  mutate(species = factor(species, levels = study_species))

ggplot(bioblitz_summary_location, aes(x = location, y = total_abundance, fill = species)) +
  geom_bar(stat = "identity", position = "dodge") + 
  facet_wrap(~ species, scales = "free_y") +
  labs(x = "Location", y = "Total Abundance", title = "Total Abundance by Location for Each Study Species") +
  scale_fill_manual(values = c("Diplodus.sargus" = "blue", 
                               "Siganus.luridus" = "green", 
                               "Siganus.rivulatus" = "purple", 
                               "Epinephelus.marginatus" = "orange")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

for (sp_i in bioblitz_df) {
  hist(filterd_bioblitz$length[filterd_bioblitz$species==sp_i],main = paste("Histogram of" , sp_i) )
}
```


# Fish thermal niche
## Extract Fish temp preference from FishBase
```{r}
for (species in unique(tags_metadata_parrot$species)) {
  if (!is.na(species)) {
    min <- estimate(species)$TempPrefMin
      max <- estimate(species)$TempPrefMax
      mean <- estimate(species)$TempPrefMean
      tags_metadata_parrot$minTemp[tags_metadata_parrot$species==species] <- min
      tags_metadata_parrot$maxTemp[tags_metadata_parrot$species==species] <- max
      tags_metadata_parrot$meanTemp[tags_metadata_parrot$species==species] <- mean
  }
      
}

```





## Estimate thermal niche edges - Bioblitz till 2023 based
```{r}
surveys_data <- read.csv("Red Sea/May surveys data/Full_data.csv")
species_list <- c("Chlorurus sordidus","Scarus fuscopurpureus","Scarus niger","Chlorurus gibbus")
surveys_data <- surveys_data %>% filter(Species %in% species_list)
surveys_data$Date <- as.Date(surveys_data$Date)
survey_temps <- read.xlsx("Red Sea/May surveys data/Temps.xlsx")
survey_temps$Date <- as.Date(survey_temps$Date,origin = "1899-12-30") ## IUI meteorological 24 hours
surveys_data <- merge(surveys_data,survey_temps,by="Date")
temp_range <- data.frame(Species=unique(surveys_data$Species),
                         max_t=NA,
                         min_t=NA)
for (specie in unique(surveys_data$Species)) {
  temp_specie <- surveys_data %>% filter(Species==specie)
  temp_range$max_t[temp_range$Species==specie] <- max(temp_specie$Temp.max)
  temp_range$min_t[temp_range$Species==specie] <- min(temp_specie$Temp.min)
}
```


# Data analysis
## Climate
### Compare IUI temp and TBR
```{r}
sst_IUI_10_min <- read.csv("Red Sea/Eilat climetology/IUI/SST_Eilat_IUI_10min.csv")
TBR_data <- read.csv("Red Sea/TBR data/All TBR sensor data - All TB acoustic files.csv")
# Formatting SST IUI 10 min
sst_IUI_10_min$DateTime <- as.POSIXct(sst_IUI_10_min$DateTime,format="%d/%m/%Y %H:%M:%S",tz = "Asia/Jerusalem")
sst_IUI_10_min <- sst_IUI_10_min %>% select(-Comments)
# Formatting TBR_Meta
TBR_metadata <- read.csv("Red Sea/TBR data/all stations from EPIC - Yuval.csv")
TBR_metadata <- TBR_metadata %>% select(rec,rec_z,period_start)
TBR_metadata <- TBR_metadata %>% rename("Receiver"="rec")
TBR_metadata <- TBR_metadata[!duplicated(TBR_metadata),]
TBR_metadata$rec_z <- ifelse(TBR_metadata$rec_z=="",NA,TBR_metadata$rec_z)
TBR_metadata <- na.omit(TBR_metadata)
TBR_metadata$period_start <- as.Date(TBR_metadata$period_start,format = "%d/%m/%Y")
TBR_metadata <- TBR_metadata[with(TBR_metadata,order(Receiver,period_start)),]

# Formatting TBR_data
TBR_data$Date.and.Time_2GMT <- as.POSIXct(TBR_data$Date.and.Time..UTC.,format="%Y-%m-%dT%H:%M:%S",tz = "UTC")
TBR_data$Date.and.Time_2GMT <- with_tz(TBR_data$Date.and.Time_2GMT,tzone="Asia/Jerusalem")
TBR_data <- TBR_data %>% select(Date.and.Time..UTC.,Date.and.Time_2GMT,Temperature..degC.,Receiver)
dates <- c(unique(fish_df$date),unique(parrotfish_data$date))
TBR_data$date <- as.Date(format(TBR_data$Date.and.Time_2GMT),tz="Asia/Jerusalem")
TBR_data <- TBR_data %>% filter(date %in% dates)
TBR_data$Serial <- 1:nrow(TBR_data)
TBR_data$depth <- NA

#Merging depth to TBR_data - stated here and continued manually in excel using xlookup
for (rec in unique(TBR_metadata$Receiver)) {
  temp_rec_meta <- TBR_metadata %>% filter(Receiver==rec)
  temp_rec_data <- TBR_data %>% filter(Receiver==rec)
  temp_rec_data <- temp_rec_data %>%
    arrange(Date.and.Time_2GMT) %>% 
    mutate(time_diff=c(NA,diff(Date.and.Time_2GMT))) %>%
    filter(time_diff==600)
  wb <- createWorkbook()
  addWorksheet(wb,"temp_rec_data")
  writeData(wb,"temp_rec_data",temp_rec_data)
  addWorksheet(wb,"temp_rec_meta")
  writeData(wb,"temp_rec_meta",temp_rec_meta)
  saveWorkbook(wb,paste("Red Sea/TBR data/Depth assigment/",rec,".xlsx"),overwrite = T)

  }

## Continue after Excel
file_list <- list.files(path = "Red Sea/TBR data/Depth assigment/", full.names = TRUE)
data_list <- list()
for (file_num in 1:length(file_list)) {
  data_list[[file_num]] <- read.xlsx(file_list[file_num],sheet="temp_rec_data")
}
data_list <- bind_rows(data_list)
data_list <- data_list %>% rename("DateTime"="Date.and.Time_2GMT")
data_list$DateTime <- as.POSIXct(data_list$Date.and.Time..UTC.,format="%Y-%m-%dT%H:%M:%S",tz = "UTC")
data_list$DateTime <- with_tz(data_list$DateTime,tzone="Asia/Jerusalem")

data_list <- merge(data_list,sst_IUI_10_min,by="DateTime")
write.csv(data_list,"Red Sea/TBR data/TBR_depth_SST.csv")

## Checking the deepest TBR
data_list_deep <-data_list %>% filter(depth==7.6) 
ggplot(data_list_deep)+
  geom_point(aes(x=DateTime,y=Temperature..degC.))

ggplot(data_list_deep)+
  geom_point(aes(x=Average.temp,y=Temperature..degC.))
```



## Fish
### load data
```{r}
# Fish data 2016-2018
fish_df <- readRDS("Red Sea/Renanel All data/2016 - 2018 parrotfish.rds") 
# Fish data 2019-2021
full_data <- readRDS("Red Sea/Renanel All data/2019 - 2021 parrotfish.rds") 
# tags metadata
tags_metadata <- read.xlsx("Red Sea/Renanel All data/ID list fish.xlsx")
  
#MHWs metadata according to different def and databases
MHWs_Eilat_Fix_OISST <- read.xlsx("Red Sea/MHWs_def/MHW_OISST_Events_RedSea_Fix.xlsx",sheet = "Short_MHW_Events_Fixed")
MHWs_Eilat_detrended_OISST <- read.xlsx("Red Sea/MHWs_def/MHW_OISST_Events_RedSea_Jacox.xlsx",sheet = "Short_MHW_Events_Fixed")
MHWs_Eilat_Fix_Amazia <- read.xlsx("Red Sea/MHWs_def/MHW_Amatzia_Events_RedSea_Fix.xlsx",sheet = "Short_MHW_Events_Fixed")
MHWs_Eilat_detrended_Amazia <- read.xlsx("Red Sea/MHWs_def/MHW_Amazia_Events_RedSea_Jacox.xlsx",sheet = "Short_MHW_Events_Fixed")

MHWs_Eilat_Fix_IUI <- read.xlsx("Red Sea/MHWs_def/MHW_IUI_1Daymean_Events_RedSea_Fix.xlsx",sheet = "Short_MHW_Events_Fixed")

#### Specifically now on the OISST Fix def and divided to two datasets based on the different time periods - need to be changed!
MHWs_fish_data <- read.csv("Red Sea/Results/MHW Daily Curves/MHW_OISST_Fixbase_Fish_data_continious.csv")
MHWs_parrotfish_data <- read.csv("Red Sea/Results/MHW Daily Curves/MHW_OISST_Fixbase_parrotfish_data_continious.csv")

```
### Filter full fish data to parrotfish/lionfish
```{r}
# filter parrotfish
tags_metadata_parrot <- tags_metadata %>% filter(fish_type=="parrotfish")
tags_metadata_parrot <- tags_metadata_parrot %>% rename("fish_id" = "id")
parrotfish_data <- full_data %>% filter(id %in% tags_metadata_parrot$fish_id)
parrotfish_data <- parrotfish_data %>% filter(!is.na(acc_tag) | !is.na(depth) )
parrotfish_data <- parrotfish_data %>% rename("fish_id" = "id")

# fliter lionfish
tags_metadata_lion <- tags_metadata %>% filter(fish_type=="lionfish")
lionfish_data <- all_fish_env %>% filter(Fish<9)
write.csv(parrotfish_data,"Red Sea/Renanel All data/parrotfish_data.csv")
write.csv(lionfish_data,"Red Sea/Renanel All data/lionfish_data.csv")
```



### Combine and format full_data and fish_df
```{r}
# Create combined dataset of the two time periods
parrotfish_data <- parrotfish_data %>% select(dt_gmt2,fish_id,acc_tag,depth)
parrotfish_data <- parrotfish_data %>% rename("real_datetime" = "dt_gmt2",
                        "activity" = "acc_tag")
parrotfish_data$real_datetime <- force_tz(parrotfish_data$real_datetime,tzone = "UTC")

fish_df <- fish_df %>% select(real_datetime,depth,size,weight,fish_id,activity,distance_shore,water_temperature)
fish_df$real_datetime <- force_tz(fish_df$real_datetime,tzone = "UTC")

combined_parrotfish_df <- bind_rows(parrotfish_data,fish_df)
combined_parrotfish_df$date <- as.Date(combined_parrotfish_df$real_datetime)
combined_parrotfish_df <- combined_parrotfish_df %>% relocate(fish_id,.before = real_datetime)
combined_parrotfish_df <- combined_parrotfish_df %>% relocate(date,.after = real_datetime)
combined_parrotfish_df <- combined_parrotfish_df %>% relocate(distance_shore,.after = depth)
combined_parrotfish_df <- combined_parrotfish_df %>% group_by(fish_id) %>%
  mutate(centered_distance = distance_shore-mean(distance_shore),
         standerized_distance=centered_distance/sd(distance_shore))
combined_parrotfish_df <- combined_parrotfish_df %>% relocate(centered_distance,.after = distance_shore) %>%
  relocate(standerized_distance,.after = centered_distance)
combined_parrotfish_df <- combined_parrotfish_df %>% arrange(fish_id,real_datetime)

# Correct negative depth values (if any exist)
combined_parrotfish_df$depth[combined_parrotfish_df$depth<0] <- 0
# Add species by fish id
combined_parrotfish_df <- merge(combined_parrotfish_df,tags_metadata_parrot[,c(1,6)],by="fish_id")
rm(fish_df,full_data,parrotfish_data)
```

### Organise, format and filter MHW_events df - after loading!
```{r}
################# Fix baseline OISST #################
#number are equal to first and last MHW date as numeric in excel
# MHWs_Eilat_Fix_OISST <- MHWs_Eilat_Fix_OISST %>% filter(duration<11 & date_start>= 42671 & date_start <= 43233)
MHWs_Eilat_Fix_OISST$date_start <- as.Date(MHWs_Eilat_Fix_OISST$date_start,origin = "1899-12-30")
MHWs_Eilat_Fix_OISST$date_peak <- as.Date(MHWs_Eilat_Fix_OISST$date_peak,origin = "1899-12-30")
MHWs_Eilat_Fix_OISST$date_end <- as.Date(MHWs_Eilat_Fix_OISST$date_end,origin = "1899-12-30")
MHWs_Eilat_Fix_OISST$start_1.5 <- as.Date(MHWs_Eilat_Fix_OISST$start_1.5,origin = "1899-12-30")
MHWs_Eilat_Fix_OISST$end_1.5 <- as.Date(MHWs_Eilat_Fix_OISST$end_1.5,origin = "1899-12-30")
MHWs_Eilat_Fix_OISST$start_3 <- as.Date(MHWs_Eilat_Fix_OISST$start_3,origin = "1899-12-30")
MHWs_Eilat_Fix_OISST$end_3 <- as.Date(MHWs_Eilat_Fix_OISST$end_3,origin = "1899-12-30")
MHWs_Eilat_Fix_OISST$Serial <- c(1:dim(MHWs_Eilat_Fix_OISST)[1])
MHWs_Eilat_Fix_OISST <- MHWs_Eilat_Fix_OISST %>% relocate(Serial,.before = date_start)

################# detrende baseline OISST ############################
MHWs_Eilat_detrended_OISST$date_start <- as.Date(MHWs_Eilat_detrended_OISST$date_start,origin = "1899-12-30")
MHWs_Eilat_detrended_OISST$date_end <- as.Date(MHWs_Eilat_detrended_OISST$date_end,origin = "1899-12-30")
MHWs_Eilat_detrended_OISST$start_1.5 <- as.Date(MHWs_Eilat_detrended_OISST$start_1.5,origin = "1899-12-30")
MHWs_Eilat_detrended_OISST$end_1.5 <- as.Date(MHWs_Eilat_detrended_OISST$end_1.5,origin = "1899-12-30")
MHWs_Eilat_detrended_OISST$start_3 <- as.Date(MHWs_Eilat_detrended_OISST$start_3,origin = "1899-12-30")
MHWs_Eilat_detrended_OISST$end_3 <- as.Date(MHWs_Eilat_detrended_OISST$end_3,origin = "1899-12-30")
MHWs_Eilat_detrended_OISST$Serial <- c(1:dim(MHWs_Eilat_detrended_OISST)[1])
MHWs_Eilat_detrended_OISST <- MHWs_Eilat_detrended_OISST %>% relocate(Serial,.before = date_start)
# Removes date peak
MHWs_Eilat_detrended_OISST <- MHWs_Eilat_detrended_OISST[-4]


################# Fix baseline Amazia #################

MHWs_Eilat_Fix_Amazia$date_start <- as.Date(MHWs_Eilat_Fix_Amazia$date_start,origin = "1899-12-30")
MHWs_Eilat_Fix_Amazia$date_end <- as.Date(MHWs_Eilat_Fix_Amazia$date_end,origin = "1899-12-30")
MHWs_Eilat_Fix_Amazia$start_1.5 <- as.Date(MHWs_Eilat_Fix_Amazia$start_1.5,origin = "1899-12-30")
MHWs_Eilat_Fix_Amazia$end_1.5 <- as.Date(MHWs_Eilat_Fix_Amazia$end_1.5,origin = "1899-12-30")
MHWs_Eilat_Fix_Amazia$start_3 <- as.Date(MHWs_Eilat_Fix_Amazia$start_3,origin = "1899-12-30")
MHWs_Eilat_Fix_Amazia$end_3 <- as.Date(MHWs_Eilat_Fix_Amazia$end_3,origin = "1899-12-30")
MHWs_Eilat_Fix_Amazia$Serial <- c(1:dim(MHWs_Eilat_Fix_Amazia)[1])
MHWs_Eilat_Fix_Amazia <- MHWs_Eilat_Fix_Amazia %>% relocate(Serial,.before = date_start)

################# detrende baseline OISST ############################
MHWs_Eilat_detrended_Amazia$date_start <- as.Date(MHWs_Eilat_detrended_Amazia$date_start,origin = "1899-12-30")
MHWs_Eilat_detrended_Amazia$date_end <- as.Date(MHWs_Eilat_detrended_Amazia$date_end,origin = "1899-12-30")
MHWs_Eilat_detrended_Amazia$start_1.5 <- as.Date(MHWs_Eilat_detrended_Amazia$start_1.5,origin = "1899-12-30")
MHWs_Eilat_detrended_Amazia$end_1.5 <- as.Date(MHWs_Eilat_detrended_Amazia$end_1.5,origin = "1899-12-30")
MHWs_Eilat_detrended_Amazia$start_3 <- as.Date(MHWs_Eilat_detrended_Amazia$start_3,origin = "1899-12-30")
MHWs_Eilat_detrended_Amazia$end_3 <- as.Date(MHWs_Eilat_detrended_Amazia$end_3,origin = "1899-12-30")
MHWs_Eilat_detrended_Amazia$Serial <- c(1:dim(MHWs_Eilat_detrended_Amazia)[1])
MHWs_Eilat_detrended_Amazia <- MHWs_Eilat_detrended_Amazia %>% relocate(Serial,.before = date_start)
# Removes date peak
MHWs_Eilat_detrended_Amazia <- MHWs_Eilat_detrended_Amazia[-4]





################# Fix baseline IUI #################

MHWs_Eilat_Fix_IUI$date_start <- as.Date(MHWs_Eilat_Fix_IUI$date_start,origin = "1899-12-30")
MHWs_Eilat_Fix_IUI$date_end <- as.Date(MHWs_Eilat_Fix_IUI$date_end,origin = "1899-12-30")
MHWs_Eilat_Fix_IUI$start_1.5 <- as.Date(MHWs_Eilat_Fix_IUI$start_1.5,origin = "1899-12-30")
MHWs_Eilat_Fix_IUI$end_1.5 <- as.Date(MHWs_Eilat_Fix_IUI$end_1.5,origin = "1899-12-30")
MHWs_Eilat_Fix_IUI$start_3 <- as.Date(MHWs_Eilat_Fix_IUI$start_3,origin = "1899-12-30")
MHWs_Eilat_Fix_IUI$end_3 <- as.Date(MHWs_Eilat_Fix_IUI$end_3,origin = "1899-12-30")
MHWs_Eilat_Fix_IUI$Serial <- c(1:dim(MHWs_Eilat_Fix_IUI)[1])
MHWs_Eilat_Fix_IUI <- MHWs_Eilat_Fix_IUI %>% relocate(Serial,.before = date_start)
```


### Calculate Each MHW summary for whole days - Need to choose dataset and change file names first!!
```{r}
####### Choose which dataset to work on through MHWs_Eilat ###########
MHWs_Eilat <- MHWs_Eilat_Fix_OISST  # Set the dataset to work with

#prepare the fish-MHWs summary dataframe 
sum_heat_wave_day <- data.frame(fish_id=numeric(),
                            Before_After=character(),
                            mean_activity=numeric(),
                            sd_activity=numeric(),
                            act_detections=numeric(),
                            Conf_int_activity=numeric(),
                            mean_depth=numeric(),
                            sd_depth=numeric(),
                            dep_detections=numeric(),
                            Conf_int_depth=numeric(),
                            Serial=numeric())

# Loop through each heatwave event
for (event in 1:dim(MHWs_Eilat)[1]) {
  # Extract fish IDs associated with the current MHW
  fish_ids <- unlist(strsplit(MHWs_Eilat$Fish_IDs, ", ")[[event]])
  
  # Check if there are valid fish IDs
  if(length(na.omit(fish_ids))>0)
  {
# Filter fish data and annotate with before/after and period of day
    filter_fish <- Filter_Fish(fish_ids,combined_parrotfish_df)  
    
    # Filter data for the mhw time frame
    MHW_Data <- filter_fish %>%
      filter(date>= MHWs_Eilat$start_1.5[event] &  date<=MHWs_Eilat$end_1.5[event]) %>% 
      Before_After_MHW(.,MHWs_Eilat$date_start[event], 
                       MHWs_Eilat$date_end[event]) %>% 
                       arrange(fish_id,real_datetime)
      
      # Create hour bins and check for sufficient observations (> 2 observations)
      obs_thrsh <- 2
      MHW_Data$hour_bin_code <- cut(MHW_Data$real_datetime,breaks = "1 hour")
      MHW_Data$hour_bin_code <-  paste(MHW_Data$fish_id,MHW_Data$hour_bin_code)
      bins_count <- MHW_Data %>%  
        group_by(hour_bin_code) %>% 
        summarise(
        non_na_activity = sum(!is.na(activity)),
        non_na_depth = sum(!is.na(depth))
        )
      bins_count_act <- bins_count[bins_count$non_na_activity >= obs_thrsh,] %>% select(hour_bin_code,non_na_activity)
      bins_count_dep <- bins_count[bins_count$non_na_depth >= obs_thrsh,] %>% select(hour_bin_code,non_na_depth)

      # Calculate summary statistics for activity
      temp_sum_heat_wave_act <- MHW_Data %>%
        filter(hour_bin_code %in% bins_count_act$hour_bin_code)%>%
        group_by(fish_id,Before_After) %>%
        summarise_at(vars(activity),funs(mean_activity = mean(.,na.rm=T),
                                 sd_activity = sd(.,na.rm=T),act_detections = sum(!is.na(.)))) %>%
        mutate(Conf_int_activity=sd_activity/sqrt(act_detections) * qt(p=0.975,df=act_detections-1))
      temp_sum_heat_wave_act <- temp_sum_heat_wave_act[temp_sum_heat_wave_act$act_detections>50,]
      
      # Calculate summary statistics for depth
      temp_sum_heat_wave_dep <- MHW_Data %>%
        filter(hour_bin_code %in% bins_count_dep$hour_bin_code)%>%
        group_by(fish_id,Before_After) %>%
        summarise_at(vars(depth),funs(mean_depth = mean(.,na.rm=T),
                                  sd_depth = sd(.,na.rm=T),dep_detections = sum(!is.na(.)))) %>%
        mutate(Conf_int_depth=sd_depth/sqrt(dep_detections) * qt(p=0.975,df=dep_detections-1))
        temp_sum_heat_wave_dep <- temp_sum_heat_wave_dep[temp_sum_heat_wave_dep$dep_detections>50,]


     # Merge summary statistics for all metrics
      temp_sum_heat_wave <- conditional_merge(temp_sum_heat_wave_dep,temp_sum_heat_wave_act,c("fish_id","Before_After"))
      temp_sum_heat_wave$Serial <- MHWs_Eilat$Serial[event]
      temp_sum_heat_wave <- Fill_In_temp_sum_heat_wave(colnames(sum_heat_wave_day),temp_sum_heat_wave)
      
      # Append the processed data to the main summary dataframe
      sum_heat_wave_day <- rbind(sum_heat_wave_day,temp_sum_heat_wave)  
      
       
  }
}
temp_sum_heat_wave_disp <- get_distance_metrics(MHWs_Eilat)
sum_heat_wave_day <- merge(sum_heat_wave_day,
           temp_sum_heat_wave_disp$sum_disp,
           by = c("Serial","fish_id","Before_After"))
# Reorganize columns in the summary dataframe
sum_heat_wave_day <- sum_heat_wave_day %>% relocate(Serial,.before = fish_id)
# Add species information from the metadata
stat_tags_metadata_parrot <- tags_metadata_parrot %>% 
  select(fish_id,species) 
sum_heat_wave_day <- distinct(merge(sum_heat_wave_day,stat_tags_metadata_parrot,by = "fish_id"))

############ Save the summary data 
############ Choose the name of the basedataset and def #############
write.csv(sum_heat_wave,paste("Red Sea/Results/Individual Heatwaves/Fish_heatwave_data_Amazia_detrended_MHW_Stage_Avg",Sys.Date(),".csv"))
```
### Calculate Each MHW summary divided by periods- Need to choose dataset and change file names first!!
```{r}
####### Choose which dataset to work on through MHWs_Eilat ###########
MHWs_Eilat <- MHWs_Eilat_Fix_OISST  # Set the dataset to work with

#prepare the fish-MHWs summary dataframe 
sum_heat_wave <- data.frame(fish_id=numeric(),
                            Before_After=character(),
                            Period=character(),
                            mean_activity=numeric(),
                            sd_activity=numeric(),
                            act_detections=numeric(),
                            Conf_int_activity=numeric(),
                            mean_depth=numeric(),
                            sd_depth=numeric(),
                            dep_detections=numeric(),
                            Conf_int_depth=numeric(),
                            Serial=numeric(),
                            window_factor=numeric()
                            )

# Loop through each heatwave event
for (event in 1:dim(MHWs_Eilat)[1]) {
  # Extract fish IDs associated with the current MHW
  fish_ids <- unlist(strsplit(MHWs_Eilat$Fish_IDs, ", ")[[event]])
  
  # Check if there are valid fish IDs
  if(length(na.omit(fish_ids))>0)
  {
# Filter fish data for the widest period and annotate with before/after and period of day
    filter_fish <- Filter_Fish(fish_ids,combined_parrotfish_df)  
    
    MHW_Data <- filter_fish %>%
      filter(date>= MHWs_Eilat$start_3[event] &  date<=MHWs_Eilat$end_3[event]) %>% 
      Before_After_MHW(.,MHWs_Eilat$date_start[event], MHWs_Eilat$date_end[event]) %>% 
      Add_Day_Period(.) %>% 
      arrange(fish_id,real_datetime)
    
    # Process data for different temporal window sizes - need to change the column numbers depend on the definition df
    for (window_size in c(20,24)) {
      start_window <-MHWs_Eilat[event,window_size]
      end_window <-MHWs_Eilat[event,window_size+2]
      
      # Filter data to the specific time window
      Windowed_MHW <- MHW_Data %>% filter(date >= start_window & date<= 
                                                end_window)
      
      # Create hour bins and check for sufficient observations (> 2 observations)
      obs_thrsh <- 2
      Windowed_MHW$hour_bin_code <- cut(Windowed_MHW$real_datetime,breaks = "1 hour")
      Windowed_MHW$hour_bin_code <-  paste(Windowed_MHW$fish_id,Windowed_MHW$hour_bin_code,Windowed_MHW$Period)
      bins_count <- Windowed_MHW %>%  
        group_by(hour_bin_code) %>% 
        summarise(
        non_na_activity = sum(!is.na(activity)),
        non_na_depth = sum(!is.na(depth)),
        non_na_dis=sum(!is.na(distance_shore))
        )
      bins_count_act <- bins_count[bins_count$non_na_activity >= obs_thrsh,] %>% select(hour_bin_code,non_na_activity)
      bins_count_dep <- bins_count[bins_count$non_na_depth >= obs_thrsh,] %>% select(hour_bin_code,non_na_depth)
      bins_count_dis <- bins_count[bins_count$non_na_dis >= obs_thrsh,] %>% select(hour_bin_code,non_na_dis)

      # Calculate summary statistics for activity
      temp_sum_heat_wave_act <- Windowed_MHW %>%
        filter(hour_bin_code %in% bins_count_act$hour_bin_code)%>%
        group_by(fish_id,Before_After,Period) %>%
        summarise_at(vars(activity),funs(mean_activity = mean(.,na.rm=T),
                                 sd_activity = sd(.,na.rm=T),act_detections = sum(!is.na(.)))) %>%
        mutate(Conf_int_activity=sd_activity/sqrt(act_detections) * qt(p=0.975,df=act_detections-1))
      temp_sum_heat_wave_act <- temp_sum_heat_wave_act[temp_sum_heat_wave_act$act_detections>50,]
      
      # Calculate summary statistics for depth
      temp_sum_heat_wave_dep <- Windowed_MHW %>%
        filter(hour_bin_code %in% bins_count_dep$hour_bin_code)%>%
        group_by(fish_id,Before_After,Period) %>%
        summarise_at(vars(depth),funs(mean_depth = mean(.,na.rm=T),
                                  sd_depth = sd(.,na.rm=T),dep_detections = sum(!is.na(.)))) %>%
        mutate(Conf_int_depth=sd_depth/sqrt(dep_detections) * qt(p=0.975,df=dep_detections-1))
        temp_sum_heat_wave_dep <- temp_sum_heat_wave_dep[temp_sum_heat_wave_dep$dep_detections>50,]



     # Merge summary statistics for all metrics
      temp_sum_heat_wave <- conditional_merge(temp_sum_heat_wave_dep,temp_sum_heat_wave_act,c("fish_id","Before_After","Period"))
      temp_sum_heat_wave$Serial <- MHWs_Eilat$Serial[event]
      temp_sum_heat_wave$window_factor <- ifelse(window_size == 20, 1.5,3)
      temp_sum_heat_wave <- Fill_In_temp_sum_heat_wave(colnames(sum_heat_wave),temp_sum_heat_wave)
      
      # Append the processed data to the main summary dataframe
      sum_heat_wave <- rbind(sum_heat_wave,temp_sum_heat_wave)  
      
    }   
  }
}
temp_sum_heat_wave_disp <- get_distance_metrics(MHWs_Eilat)
sum_heat_wave <- merge(sum_heat_wave,
           temp_sum_heat_wave_disp$sum_disp,
           by = c("Serial","fish_id","Before_After"))
# Reorganize columns in the summary dataframe
sum_heat_wave <- sum_heat_wave %>% relocate(Serial,.before = fish_id)
sum_heat_wave <- sum_heat_wave %>% relocate(window_factor,.before = fish_id)

# Add species information from the metadata
stat_tags_metadata_parrot <- tags_metadata_parrot %>% 
  select(fish_id,species) 
sum_heat_wave <- distinct(merge(sum_heat_wave,stat_tags_metadata_parrot,by = "fish_id"))

############ Save the summary data 
############ Choose the name of the basedataset and def #############
write.csv(sum_heat_wave,paste("Red Sea/Results/Individual Heatwaves/Fish_heatwave_data_Amazia_detrended_MHW_Stage_Avg",Sys.Date(),".csv"))

# Nest the data by Serial and window_factor
nest_hw <- sum_heat_wave %>% 
  ungroup() %>%
  nest_by(Serial,window_factor)

# Save the nested data
saveRDS(nest_hw,paste("Red Sea/Results/Individual Heatwaves/Nested_heatwaves_Amazia_detrended_MHW_Stage_Avg",Sys.Date(),".RDS"))
```


### Calculate means before and after the heat wave - long : Continue to the MHW Summary section
```{r}
# Initialize an empty dataframe to store the results
MHWs_comparison <- data.frame(
  fish_id=numeric(), # ID of the fish
  Serial = numeric(),              # Serial number for the heatwave event
  window_factor = numeric(),       # Factor indicating the analysis window size
  Period_of_day = character(),     # Period of the day (e.g., Dawn , Day)
  ln_activity_ratio = numeric(),   # Logarithmic ratio of activity levels between stages
  delta_depth = numeric(),         # Change in depth between stages
  # delta_distance = numeric(),      # Change in distance from shore between stages
  Stage_period = character()       # Describes the stage comparison (e.g., "MHW : Before")
)

# Iterate over each heatwave event
for (event_calc in 1:dim(nest_hw)[1]) {
  temp_heat_wave <- nest_hw$data[[event_calc]]  # Extract data for the current event
  # If contains date
  # temp_heat_wave <- temp_heat_wave %>%
  #   rename("activity" = "activity_mean",
  #          "depth" = "depth_mean",
  #          "distance_shore" = "distance_shore_mean") %>%
  #   group_by(fish_id,Before_After,Check_period)
  # # %>%
  #   summarise_at(vars(activity,depth,distance_shore),funs(mean(.,na.rm=T), median(.,na.rm=T),
  #                                                       sd(.,na.rm=T),n()))
  #
  
  # With MHW stage
  # Iterate over each unique fish ID in the heatwave data
  for (fish in unique(temp_heat_wave$fish_id)) {
    temp_fish <- temp_heat_wave %>% filter(fish_id==fish) # Filter data for the current fish
    # Iterate over each period of the day
    for (period in unique(temp_heat_wave$Period)) {
      
      temp_period <- temp_fish %>% filter(Period==period) # Filter data for the current period
      
      # Initialize a temporary row for storing results
      temp_row <- data.frame(
                  fish_id=rep(fish,3),# Repeat fish ID
        Serial = rep(nest_hw$Serial[[event_calc]], 3),   # Repeat serial for current event
        window_factor = rep(nest_hw$window_factor[[event_calc]], 3), # Repeat window factor
        Period_of_day = rep(period, 3),                 # Repeat current period
        ln_activity_ratio = rep(NA, 3),                 # Placeholder for activity ratio
        delta_depth = rep(NA, 3),                       # Placeholder for depth change
        Stage_period = rep(NA, 3)                       # Placeholder for stage comparison label
      )
      
      uniqe_stages <- unique(temp_period$Before_After) # Get unique stages (e.g., "Before", "MHW", "After")
      row_i <- 1 # Initialize row index for temporary row
      
      # Check and calculate metrics for "MHW : Before" stage comparison
                  if(all(c("MHW","Before") %in% uniqe_stages))
                  {
                    temp_row$ln_activity_ratio[row_i] <- log(temp_period$mean_activity[temp_period$Before_After=="MHW"] /temp_period$mean_activity[temp_period$Before_After=="Before"])
                    temp_row$delta_depth[row_i] <- temp_period$mean_depth[temp_period$Before_After=="MHW"] - temp_period$mean_depth[temp_period$Before_After=="Before"]
                    temp_row$Stage_period[row_i] <- "MHW : Before" # Label the stage comparison
                    row_i <- row_i+1 # Increment row index
                  }
      
      # Check and calculate metrics for "After : MHW" stage comparison
                  if(all(c("After","MHW") %in% uniqe_stages))
                  {
                     temp_row$ln_activity_ratio[row_i] <- log(temp_period$mean_activity[temp_period$Before_After=="After"]/temp_period$mean_activity[temp_period$Before_After=="MHW"])
                     temp_row$delta_depth[row_i] <- temp_period$mean_depth[temp_period$Before_After=="After"] - temp_period$mean_depth[temp_period$Before_After=="MHW"]
                     # temp_row$delta_distance[row_i] <-
                     # abs(temp_period$distance_shore_mean[temp_period$Before_After=="After"] - temp_period$distance_shore_mean[temp_period$Before_After=="MHW"])
                     temp_row$Stage_period[row_i] <- "After : MHW"
                    row_i <- row_i+1
                  }
      
       # Check and calculate metrics for "After : Before" stage comparison
                  if(all(c("After","Before") %in% uniqe_stages))
                  {
                    temp_row$ln_activity_ratio[row_i] <- log(temp_period$mean_activity[temp_period$Before_After=="After"]/temp_period$mean_activity[temp_period$Before_After=="Before"])
                    temp_row$delta_depth[row_i] <- temp_period$mean_depth[temp_period$Before_After=="After"] - temp_period$mean_depth[temp_period$Before_After=="Before"]
                    # temp_row$delta_distance[row_i] <-
                    # abs(temp_period$distance_shore_mean[temp_period$Before_After=="After"] - temp_period$distance_shore_mean[temp_period$Before_After=="Before"])
                    temp_row$Stage_period[row_i] <- "After : Before"
                  }
      # Append the temporary row to the main results dataframe
      MHWs_comparison <- rbind(MHWs_comparison,temp_row)
    }
  }
}

# Remove rows where all metrics (activity, depth, distance) are NA
MHWs_comparison <- MHWs_comparison %>% filter(!(is.na(ln_activity_ratio) & is.na(delta_depth)))

long_disp_comparison <- temp_sum_heat_wave_disp$comparison_disp %>%
  select(Serial, fish_id, starts_with("delta_"), starts_with("log_")) %>%
  pivot_longer(
    cols = -c(Serial, fish_id),
    names_to = c(".value", "Stage_period"),
    names_pattern = "(delta|log)_(.*)"
  ) %>%
  mutate(
    Stage_period = recode(Stage_period,
                          "MHW_Before" = "MHW : Before",
                          "After_Before" = "After : Before")
  )%>%
  rename(
    `delta_max_displacement` = delta,
    `log_max_displacement` = log
  )
MHWs_comparison <- merge(MHWs_comparison,long_disp_comparison,by=c("Serial","fish_id","Stage_period"))

# Merge with heatwave metadata
############ Choose the name of the basedataset and def #############
MHWs_comparison <- merge(MHWs_comparison,MHWs_Eilat,by = "Serial") %>%  select(-Fish_IDs)

# Add species information from the metadata
stat_tags_metadata_parrot <- tags_metadata_parrot %>% 
  select(fish_id,species) 
MHWs_comparison <- distinct(merge(MHWs_comparison,stat_tags_metadata_parrot,by = "fish_id"))

# Save the final results to CSV 
############ Choose the name of the basedataset and def #############
write.csv(MHWs_comparison,paste("Red Sea/Results/Individual Heatwaves/MHWs_comparison_Amazia_detrended",Sys.Date(),".csv"))
```



### Disatnce statistical tests - including sensitivity test
```{r}
MHW_daily_distance_df <- get_MHW_fish_df(MHWs_Eilat) 
MHW_daily_distance_df <- MHW_daily_distance_df %>%
  mutate(hour = hour(real_datetime)) %>%     # Extract hour
  Add_Day_Period(.) %>% 
  arrange(fish_id,real_datetime) %>%
  mutate(solar_date = case_when(
      Period == "Night" & hour < 12 ~ date - 1,  # Early Night (after midnight) â†’ subtract 1 day
      TRUE ~ date  # Otherwise keep the same
    )) %>% 
  relocate(hour,Period,solar_date,.after = date) %>% 
  ungroup()

daily_distance_summary <- MHW_daily_distance_df %>%
  group_by(Serial,fish_id, solar_date) %>%
  filter(!is.na(distance_shore)) %>%
  summarise(
    n = n(),
    # Max daily displacement: median of the top 10% - median of the bottom 10%
    max_daily_displacement_10 = {
      sorted_distances <- distance_shore[Period == "Day"]
      sorted_distances <- sort(distance_shore, na.last = NA)
      n <- length(sorted_distances)
      ifelse(n>10,
             {
              top_10_percent <- sorted_distances[ceiling(0.9 * n):n]
              bottom_10_percent <- sorted_distances[1:floor(0.1 * n)]
              abs(median(top_10_percent, na.rm = TRUE) - 
                    median(bottom_10_percent, na.rm = TRUE))         
              }
      ,NA)
      
    },
    # Max daily displacement: median of the top 10% - median of the bottom 10%
    max_daily_displacement_30 = {
      sorted_distances <- distance_shore[Period == "Day"]
      sorted_distances <- sort(distance_shore, na.last = NA)
      n <- length(sorted_distances)
      ifelse(n>30,
             {
              top_10_percent <- sorted_distances[ceiling(0.9 * n):n]
              bottom_10_percent <- sorted_distances[1:floor(0.1 * n)]
              abs(median(top_10_percent, na.rm = TRUE) - 
                    median(bottom_10_percent, na.rm = TRUE))         
              }
      ,NA)
      
    },
    # Max daily displacement: median of the top 10% - median of the bottom 10%
    max_daily_displacement_50 = {
      sorted_distances <- distance_shore[Period == "Day"]
      sorted_distances <- sort(distance_shore, na.last = NA)
      n <- length(sorted_distances)
      ifelse(n>50,
             {
              top_10_percent <- sorted_distances[ceiling(0.9 * n):n]
              bottom_10_percent <- sorted_distances[1:floor(0.1 * n)]
              abs(median(top_10_percent, na.rm = TRUE) - 
                    median(bottom_10_percent, na.rm = TRUE))         
              }
      ,NA)
      
    },

    # Night counts (hour between 22:00 and 4:00)
    night_count = sum(hour >= 22 | hour < 4),

    # Night displacement for 5
    night_median_6 = if_else(
      night_count > 6,
      median(distance_shore[hour >= 22 | hour < 4], na.rm = TRUE),
      NA_real_
    ),
    night_displacement_6 =
      {
      filter_distances <- distance_shore[Period == "Day" | Period == "Dusk" | 
                                           Period =="Dawn"]
      sorted_distances <- sort(filter_distances, na.last = NA)
      n <- length(sorted_distances)
      top_10_percent <- sorted_distances[ceiling(0.9 * n):n]
      abs(top_10_percent - night_median_6)
      }
    ,

    # Night displacement for 10
    night_median_12 = if_else(
      night_count > 12,
      median(distance_shore[hour >= 22 | hour < 4], na.rm = TRUE),
      NA_real_),
    night_displacement_12 = {
      filter_distances <- distance_shore[Period == "Day" | Period == "Dusk" | 
                                           Period == "Dawn"]
      sorted_distances <- sort(filter_distances, na.last = NA)    
      n <- length(sorted_distances)
      top_10_percent <- sorted_distances[ceiling(0.9 * n):n]
      abs(top_10_percent - night_median_12)
      }
    ,

    # Night displacement for 15
    night_median_18 = if_else(
      night_count > 18,
      median(distance_shore[hour >= 22 | hour < 4], na.rm = TRUE),
      NA_real_),
    night_displacement_18 = {
      filter_distances <- distance_shore[Period == "Day" | Period == "Dusk" | 
                                           Period == "Dawn"]
      sorted_distances <- sort(filter_distances, na.last = NA)
      n <- length(sorted_distances)
      top_10_percent <- sorted_distances[ceiling(0.9 * n):n]
      abs(top_10_percent - night_median_18)
      },

    size = first(size),
    species = first(species),
    Before_After = first(Before_After),
    date_start = first(date_start),
    date_peak = first(date_peak),
    date_end = first(date_end),
    duration = first(duration),
    intensity_mean = first(intensity_mean),
    intensity_max = first(intensity_max),
    intensity_var = first(intensity_var),
    intensity_cumulative = first(intensity_cumulative),
    intensity_mean_relThresh = first(intensity_mean_relThresh),
    intensity_max_relThresh = first(intensity_max_relThresh),
    intensity_var_relThresh = first(intensity_var_relThresh),
    intensity_mean_abs = first(intensity_mean_abs),
    intensity_max_abs = first(intensity_max_abs),
    intensity_var_abs = first(intensity_var_abs),
    rate_onset = first(rate_onset),
    rate_decline = first(rate_decline),
    # Category = first(Category),
    start_1.5 = first(start_1.5),
    reliability_level = first(reliabaility.level),
    end_1.5 = first(end_1.5),
    reliability_level_1 = first(reliabaility.level.1),
    start_3 = first(start_3),
    reliability_level_2 = first(reliabaility.level.2),
    end_3 = first(end_3),
    reliability_level_3 = first(reliabaility.level.3)
  ) %>%
  ungroup()%>%
  distinct(Serial,fish_id, solar_date, .keep_all = TRUE)  # Remove duplicates explicitly




hist(daily_distance_summary$max_daily_displacement_10)
hist(daily_distance_summary$max_daily_displacement_30)
hist(daily_distance_summary$max_daily_displacement_50)
long_max_displacement_df <- daily_distance_summary %>%
  pivot_longer(cols = starts_with("max_daily"),
               names_to = "displacement_type",
               values_to = "distance")
max_sens <- ggplot(long_max_displacement_df, aes(x = displacement_type, y = distance)) +
  stat_summary(fun = mean, geom = "point", size = 4) +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0.2) +
  labs(x = "Displacement Type", y = "Mean max daily displacment (m)") +
  theme_minimal()
ggsave("Red Sea/Results/Sensitivity/max_displacment.svg",max_sens)

# Night displacment check
hist(daily_distance_summary$night_displacement_6)
hist(daily_distance_summary$night_displacement_12)
hist(daily_distance_summary$night_displacement_18)
long_night_displacement_df <- daily_distance_summary %>%
  pivot_longer(cols = starts_with("night_displacement_"),
               names_to = "displacement_type",
               values_to = "distance")

night_sens <- ggplot(long_night_displacement_df, aes(x = displacement_type, y = distance)) +
  stat_summary(fun = mean, geom = "point", size = 4) +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0.2) +
  labs(x = "Displacement Type", y = "Mean night displacment (m)") +
  theme_minimal()
ggsave("Red Sea/Results/Sensitivity/night_displacment.svg",night_sens)

# stage displacement check - max ang night
hist(daily_distance_summary$max_daily_displacement_10[daily_distance_summary$Before_After=="Before"])
hist(daily_distance_summary$max_daily_displacement_10[daily_distance_summary$Before_After=="MHW"])
hist(daily_distance_summary$max_daily_displacement_10[daily_distance_summary$Before_After=="After"])

hist(daily_distance_summary$night_displacement_6[daily_distance_summary$Before_After=="Before"])
hist(daily_distance_summary$night_displacement_6[daily_distance_summary$Before_After=="MHW"])
hist(daily_distance_summary$night_displacement_6[daily_distance_summary$Before_After=="After"])


# Calculate the mean and CI for each serial_fish_id and Before_After
MHW_disp_summary <- daily_distance_summary %>%
  group_by(Serial,fish_id,Serial_fish_id,Before_After) %>%
  summarise(
    mean_disp_max = mean(max_daily_displacement, na.rm = TRUE),
    sd_disp_max = sd(max_daily_displacement_10, na.rm = TRUE),  # Standard deviation
    n_disp_max = sum(!is.na(max_daily_displacement_10)),  # Number of non-NA values
    ci_lower_max = mean_disp_max - (1.96 * (sd_disp_max / sqrt(n_disp_max))),  # Lower CI
    ci_upper_max = mean_disp_max + (1.96 * (sd_disp_max / sqrt(n_disp_max))),  # Upper CI
    
    mean_disp_night = mean(night_displacement_6, na.rm = TRUE),
    sd_disp_night = sd(night_displacement_6, na.rm = TRUE),
    n_disp_night = sum(!is.na(night_displacement_6)),
    ci_lower_night = mean_disp_night - (1.96 * (sd_disp_night / sqrt(n_disp_night))),
    ci_upper_night = mean_disp_night + (1.96 * (sd_disp_night / sqrt(n_disp_night))),
    
    .groups = 'drop'
  )


# Max displacment plot
ggplot(MHW_disp_summary, aes(x = Before_After, y = mean_disp_max)) +
  geom_boxplot(aes(fill = Before_After), alpha = 0.7, show.legend = FALSE) +
  scale_fill_manual(values = c("Before" = "forestgreen", 
                               "MHW" = "red", 
                               "After" = "dodgerblue")) +
  # Add mean points and CI
  stat_summary(
    fun = mean, 
    geom = "point", 
    shape = 18,  # Diamond shape for the mean
    size = 4, 
    color = "black"
  ) +
  stat_summary(
    fun.data = mean_cl_normal, 
    geom = "errorbar", 
    width = 0.1, 
    color = "black", 
    linewidth = 0.8
  ) +
  
  # Facet by species if needed (if species is present in MHW_disp_summary)
  # facet_wrap(~species, scales = "free_y") +
  
  labs(
    x = "Stage", 
    y = "Mean maximum Displacment (m)"
  ) +
  theme_bw() +
  theme(legend.position = "top")

# Night displacment plot
ggplot(MHW_disp_summary, aes(x = Before_After, y = mean_disp_night)) +
  geom_boxplot(aes(fill = Before_After), alpha = 0.7, show.legend = FALSE) +
  scale_fill_manual(values = c("Before" = "forestgreen", 
                               "MHW" = "red", 
                               "After" = "dodgerblue")) +
  # Add mean points and CI
  stat_summary(
    fun = mean, 
    geom = "point", 
    shape = 18,  # Diamond shape for the mean
    size = 4, 
    color = "black"
  ) +
  stat_summary(
    fun.data = mean_cl_normal, 
    geom = "errorbar", 
    width = 0.1, 
    color = "black", 
    linewidth = 0.8
  ) +
  
  # Facet by species if needed (if species is present in MHW_disp_summary)
  # facet_wrap(~Serial_fish_id, scales = "free_y") +
  
  labs(
    x = "Stage", 
    y = "Mean Distance from Shore (m)"
  ) +
  theme_bw() +
  theme(legend.position = "top")

# Step 2: Calculate delta between stages (e.g., MHW - Before, After - Before)
MHW_disp_comparison <- MHW_disp_summary %>%
  select(Serial_fish_id,Before_After,mean_disp_max) %>% 
  pivot_wider(names_from = Before_After, values_from = mean_disp_max) %>%
  mutate(
    delta_MHW_Before = abs(`MHW` - `Before`),  # MHW - Before
    delta_After_Before = abs(`After` - `Before`),  # After - Before
    log_MHW_Before = ifelse(is.finite(log(`MHW` / `Before`)), log(`MHW` / `Before`), NA_real_),
    log_After_Before = ifelse(is.finite(log(`After` / `Before`)), log(`After` / `Before`), NA_real_)
    )

```



### Definiton summary
```{r}
MHW_count <- length(unique(sum_heat_wave$Serial))

MHW_fish_count <- length(unique(sum_heat_wave$fish_id))

mhw_species <- sum_heat_wave %>% 
  group_by(species) %>% 
  summarise(n_fish = n_distinct(fish_id))
mhw_Serial_species <- sum_heat_wave %>% 
  group_by(Serial,species) %>% 
  summarise(n_fish = n_distinct(fish_id))


min_fish <- sum_heat_wave %>%
  group_by(Serial) %>%
  summarise(n_fish = n_distinct(fish_id)) %>%
  summarise(min_fish = min(n_fish)) %>%
  pull(min_fish)

max_fish <- sum_heat_wave %>%
  group_by(Serial) %>%
  summarise(n_fish = n_distinct(fish_id)) %>%
  summarise(max_fish = max(n_fish)) %>%
  pull(max_fish)

mhw_depths <- sum_heat_wave %>%
  filter(!is.na(mean_depth))
mhws_with_depth <-  mhw_depths %>% 
  distinct(Serial)
fish_with_depth <- mhw_depths %>% 
  distinct(fish_id)
fish_with_depth_per_stage <- mhw_depths %>% 
  group_by(Before_After) %>%
  summarise(n_fish_with_depth = n_distinct(fish_id)) %>%
  arrange(Before_After)

mhw_activity <- sum_heat_wave %>%
  filter(!is.na(mean_activity))
mhws_with_activity <-mhw_activity  %>%
  distinct(Serial)
fish_with_activity <- mhw_activity %>% 
  distinct(fish_id)
fish_with_activity_per_stage <- mhw_activity %>% 
  group_by(Before_After) %>%
  summarise(n_fish_with_activity = n_distinct(fish_id)) %>%
  arrange(Before_After)

mhw_distance <- sum_heat_wave %>%
  filter(!is.na(mean_disp_max))
mhws_with_distance <-  mhw_distance %>% 
  distinct(Serial)
fish_with_distance <- mhw_distance %>% 
  distinct(fish_id)
fish_with_distance_per_stage <- mhw_distance %>% 
  group_by(Before_After) %>%
  summarise(n_fish_with_distance = n_distinct(fish_id)) %>%
  arrange(Before_After)

cat("----- MHW and Fish Data Summary -----\n\n")

cat("Total number of MHW events (Serial):", MHW_count, "\n")
cat("Total number of unique fish tagged during MHW study:", MHW_fish_count, "\n\n")
cat("Minimum number of fish per MHW event:", min_fish, "\n")
cat("Maximum number of fish per MHW event:", max_fish, "\n")
cat("Number of fish per species in specific MHW defintion:")
print(mhw_species)
cat("Number of fish per species MHW event:")
print( mhw_Serial_species)

cat("Number of MHW events with activity data:", nrow(mhws_with_activity), "\n")
cat("Number of fish with activity data:", nrow(fish_with_activity), "\n\n")

cat("Fish with activity data per MHW stage:\n")
print(fish_with_activity_per_stage)

cat("Number of MHW events with depth data:", nrow(mhws_with_depth), "\n")
cat("Number of fish with depth data:", nrow(fish_with_depth), "\n\n")

cat("Fish with depth data per MHW stage:\n")
print(fish_with_depth_per_stage)
cat("\n")

cat("Number of MHW events with displacment data:", nrow(mhws_with_distance), "\n")
cat("Number of fish with displacment data:", nrow(fish_with_distance), "\n\n")

cat("Fish with displacment data per MHW stage:\n")
print(fish_with_distance_per_stage)
cat("\n--------------------------------------\n")

```

### MHW stats graphs and lm
```{r}

## Activity 

# Only MHW:Before
MHWs_comparison_lm <- MHWs_comparison %>% filter(window_factor==1.5 & Stage_period=="MHW : Before" )

## Several stage period
# MHWs_comparison_lm <- MHWs_comparison %>% filter(window_factor==1.5 & (Stage_period=="MHW : Before" | Stage_period=="After : MHW"))

# Make sure factor levels are in correct order
sum_heat_wave_day$Before_After <- factor(sum_heat_wave_day$Before_After,
                                 levels = c("Before", "MHW", "After"))

hist(MHWs_comparison_lm$ln_activity_ratio)
lm_act<- lm(ln_activity_ratio ~ intensity_cumulative,data = MHWs_comparison_lm)
gratia::appraise(lm_act)
summary(lm_act)

# Make sure factor levels are in correct order
MHWs_comparison_lm$Stage_period <- factor(MHWs_comparison_lm$Stage_period,
                                 levels = c("MHW : Before", "After : Before", "After : MHW"))


# Step 1: Summarize n per group
# Summary stats for label positioning
n_df_act <- MHWs_comparison_lm %>%
  group_by(intensity_cumulative) %>%
  filter(!is.na(ln_activity_ratio)) %>% 
  summarise(n = n(),
            mean_ln = mean(ln_activity_ratio, na.rm = TRUE),
            .groups = "drop") 

act_reg_plot <- ggplot(MHWs_comparison_lm, aes(x = intensity_cumulative, y = ln_activity_ratio)) +
  stat_summary(fun = mean, geom = "point", size = 3, color = "black") +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0.2, color = "black") +
  geom_smooth(method = "lm", se = TRUE, color = "darkred", linewidth = 1.4) +
  stat_poly_eq(
    aes(label = paste(..rr.label.., ..p.value.label.., sep = "~~~")),
    formula = y ~ x,
    parse = TRUE,
    label.x = "center",
    label.y = 0.9,
    size = 6,
    color = "black"
  ) +
  scale_x_continuous(breaks = seq(0, 30, by = 5)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  # geom_text(data = n_df_act, aes(x = intensity_cumulative, y=Inf , label = n),
  #           inherit.aes = FALSE, size = 3, fontface = "bold",vjust=2) +
  # facet_wrap(~ Stage_period) +
  labs(
    y = "ln(Activity Ratio)"
  ) +
  theme_bw()+
  theme(panel.grid = element_blank(),
        axis.title.x = element_blank(),
        axis.text = element_text(size = 18,color = "black"),
        axis.title = element_text(size = 20))


# Filter out rows with NA activity
sum_heat_wave_act <- sum_heat_wave_day %>%
  filter(!is.na(mean_activity))
sum_heat_wave_act$Serial_fish_id <- paste0(sum_heat_wave_act$Serial,"_",sum_heat_wave_act$fish_id) 
sum_heat_wave_act$Serial_fish_id <- as.factor(sum_heat_wave_act$Serial_fish_id)

# Plot
sum_heat_wave_act <- sum_heat_wave_act %>%
  mutate(
    x_pos = as.numeric(Before_After),  # e.g., Before=1, MHW=2, After=3
    x_jittered = x_pos + runif(n(), min = -0.5, max = 0.5)  # consistent jitter
  ) %>% 
  group_by(Serial_fish_id) %>%
  filter(n_distinct(Before_After) > 1) %>%
  ungroup()
n_counts_act <- sum_heat_wave_act %>%
  group_by(Before_After, x_pos) %>%
  summarise(n = n(), .groups = "drop")
act_symbol_compare_plot <- ggplot(sum_heat_wave_act) +
  geom_line(aes(x = x_jittered, y = mean_activity, group = Serial_fish_id),
            color = "grey60", alpha = 0.5, linewidth = 0.5)+
  # geom_boxplot(aes(fill = Before_After),alpha = 0.7,show.legend = FALSE) +
   geom_point(aes(x = x_jittered, y = mean_activity, fill = Before_After),
             shape = 21, size = 3, alpha = 0.5) +
  scale_fill_manual(values = c("Before" = "#2E8B57",
                               "MHW" = "#DC143C",
                               "After" = "#4169E1")) +
  scale_shape_manual(values = c("Dawn" = 2,
                                "Day" = 8,
                                "Dusk" = 0,
                                "Night" = 3)) +
  # geom_jitter(aes(shape = Period),position = position_jitterdodge(jitter.width = 0.15, dodge.width = 0.8),size=2.5)+
  # facet_wrap(~species,scales="free_y")+
  stat_summary(
    aes(x = x_pos, y = mean_activity),
    fun.data = function(x) {
      m <- mean(x)
      se <- sd(x) / sqrt(length(x))
      data.frame(
        y = m,
        ymin = m - 1.96 * se ,  
        ymax = m + 1.96 * se    
      )
        },
    geom = "errorbar",
    width = 0.1,
    color = "black",
    linewidth = 0.8,
    ) +
  # Add mean points and CI
  stat_summary(
    aes(x = x_pos, y = mean_activity, fill = Before_After),
    fun = mean,
    geom = "point",
    shape = 21, # Diamond shape
    size = 7,
    color = "black",
    stroke=1.2
  ) +
  geom_text(
    data = n_counts_act,
    aes(x = x_pos, y = max(sum_heat_wave_act$mean_activity, na.rm = TRUE) + 0.1, label = n),
    size = 5
  )+
  # Add mean points and CI
  # stat_summary(
  #   fun = mean,
  #   geom = "point",
  #   shape = 18, # Diamond shape
  #   size = 4,
  #   color = "black"
  # ) +
  # stat_summary(
  #   fun.data = mean_cl_normal,
  #   geom = "errorbar",
  #   width = 0.1,
  #   color = "black",
  #   linewidth = 0.8
  # ) +
  scale_x_continuous(
    breaks = c(1, 2, 3),
    labels = c("Before", "MHW", "After")
  ) +
  labs(
    y = "Mean Activity [m/sÂ²]"
  ) +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        axis.title.x = element_blank(),
        axis.text = element_text(size = 18,color = "black"),
        axis.title = element_text(size = 20))

ggsave("Red Sea/Results/Plots/act_symb_compare_plot_species_OISST_Fix.svg", act_symbol_compare_plot, width = 12, height = 10)

## Depth

lm_dep<- lm(delta_depth ~ intensity_cumulative,data = MHWs_comparison_lm)
gratia::appraise(lm_dep)
summary(lm_dep)

# Step 1: Summarize n per group
# Summary stats for label positioning
n_df_dep <- MHWs_comparison_lm %>%
  group_by(intensity_cumulative) %>%
  filter(!is.na(delta_depth)) %>% 
  summarise(n = n(),
            mean_ln = mean(delta_depth, na.rm = TRUE),
            .groups = "drop") 

dep_reg_plot <- ggplot(MHWs_comparison_lm, aes(x = intensity_cumulative, y = delta_depth)) +
  stat_summary(fun = mean, geom = "point", size = 3, color = "black") +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0.2, color = "black") +
  geom_smooth(method = "lm", se = TRUE, color = "darkred", linewidth = 1.4) +
  stat_poly_eq(
    aes(label = paste( ..rr.label.., ..p.value.label.., sep = "~~~")),
    formula = y ~ x,
    parse = TRUE,
    label.x = "center",
    label.y = 0.9,
    size = 6,
    color = "black"
  ) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  # geom_text(data = n_df_dep, aes(x = intensity_cumulative, y=Inf , label = n),inherit.aes = FALSE, size = 3, fontface = "bold",vjust=2) +
  labs(
    x = "Cumulative Intensity [Â°C days]",
    y = "Delta depth [m]"
  ) +
  scale_x_continuous(breaks = seq(0, 30, by = 5)) +
  theme_bw()+
  theme(panel.grid = element_blank(),
        axis.text = element_text(size = 18,color = "black"),
        axis.title = element_text(size = 20))

# Filter out rows with NA depth
sum_heat_wave_dep <- sum_heat_wave_day %>%
  filter(!is.na(mean_depth))
sum_heat_wave_dep$Serial_fish_id <- paste0(sum_heat_wave_dep$Serial,"_",sum_heat_wave_dep$fish_id) 
sum_heat_wave_dep$Serial_fish_id <- as.factor(sum_heat_wave_dep$Serial_fish_id)

# Plot
sum_heat_wave_dep <- sum_heat_wave_dep %>%
  mutate(
    x_pos = as.numeric(Before_After),  # e.g., Before=1, MHW=2, After=3
    x_jittered = x_pos + runif(n(), min = -0.1, max = 0.1)  # consistent jitter
  ) %>% 
  group_by(Serial_fish_id) %>%
  filter(n_distinct(Before_After) > 1) %>%
  ungroup()
n_counts_dep <- sum_heat_wave_dep %>%
  group_by(Before_After, x_pos) %>%
  summarise(n = n(), .groups = "drop")

# Plot
dep_symbol_compare_plot <- ggplot(sum_heat_wave_dep) +
  geom_line(aes(x = x_jittered, y = mean_depth, group = Serial_fish_id),
            color = "grey60", alpha = 0.5, linewidth = 0.5)+
  # geom_boxplot(aes(fill = Before_After),alpha = 0.7,show.legend = FALSE) +
  geom_point(aes(x = x_jittered, y = mean_depth, fill = Before_After),
             shape = 21, size = 3, alpha = 0.5) +
  scale_fill_manual(values = c("Before" = "#2E8B57",
                               "MHW" = "#DC143C",
                               "After" = "#4169E1"))+
  scale_shape_manual(values = c("Dawn" = 2,
                                "Day" = 8,
                                "Dusk" = 0,
                                "Night" = 3)) +
  # facet_wrap(~species,scales="free_y")+
  # geom_jitter(aes(shape = Period),position = position_jitterdodge(jitter.width = 0.15, dodge.width = 0.8),size=2.5)+
  scale_y_reverse()+
  coord_cartesian(ylim = c(max(sum_heat_wave_dep$mean_depth, na.rm = TRUE), 0)) +  # Clip at 0
  stat_summary(
    aes(x = x_pos, y = mean_depth),
    fun.data = function(x) {
      m <- mean(x)
      se <- sd(x) / sqrt(length(x))
      data.frame(
        y = m,
        ymin = m - 1.96 * se ,  
        ymax = m + 1.96 * se    
      )
        },
    geom = "errorbar",
    width = 0.1,
    color = "black",
    linewidth = 0.8,
    ) +
  # Add mean points and CI
  stat_summary(
    aes(x = x_pos, y = mean_depth, fill = Before_After),
    fun = mean,
    geom = "point",
    shape = 21, # Diamond shape
    size = 7,
    color = "black",
    stroke=1.2
  ) +
  geom_text(
    data = n_counts_dep,
    aes(x = x_pos, y = 0, label = n),
    size = 5
  )+
  # Add mean points and CI
  # stat_summary(
    # fun = mean,
    # geom = "point",
    # shape = 18, # Diamond shape
    # size = 4,
    # color = "black"
  # ) +
  # stat_summary(
  #   fun.data = mean_cl_normal,
  #   geom = "errorbar",
  #   width = 0.1,
  #   color = "black",
  #   linewidth = 0.8
  # ) +
  scale_x_continuous(
    breaks = c(1, 2, 3),
    labels = c("Before", "MHW", "After")
  ) +
  labs(
    x = "MHW Stage",
    y = "Mean Depth [m]"
  ) +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        axis.text = element_text(size = 18,color = "black"),
        axis.title = element_text(size = 20))
ggsave("Red Sea/Results/Plots/dep_symb_compare_plot_OISST_Fix.svg", dep_symbol_compare_plot, width = 12, height = 10)


## Displacment


# Only MHW:Before
MHWs_comparison_lm <- MHWs_comparison %>% filter(window_factor==1.5 & Stage_period=="MHW : Before" )

## Several stage period
# MHWs_comparison_lm <- MHWs_comparison %>% filter(window_factor==1.5 & (Stage_period=="MHW : Before" | Stage_period=="After : MHW"))

# Make sure factor levels are in correct order
sum_heat_wave$Before_After <- factor(sum_heat_wave$Before_After,
                                 levels = c("Before", "MHW", "After"))

hist(MHWs_comparison_lm$log_max_displacement)
lm_disp<- lm(log_max_displacement ~ intensity_cumulative,data = MHWs_comparison_lm)
gratia::appraise(lm_disp)
summary(lm_disp)

# Make sure factor levels are in correct order
MHWs_comparison_lm$Stage_period <- factor(MHWs_comparison_lm$Stage_period,
                                 levels = c("MHW : Before", "After : Before", "After : MHW"))


# Step 1: Summarize n per group
# Summary stats for label positioning
n_df_disp <- MHWs_comparison_lm %>%
  select(-Period_of_day,-ln_activity_ratio,-delta_depth) %>% 
  distinct() %>% 
  group_by(intensity_cumulative) %>%
  filter(!is.na(log_max_displacement)) %>% 
  summarise(n = n(),
            mean_ln = mean(log_max_displacement, na.rm = TRUE),
            .groups = "drop") 

disp_reg_plot <- ggplot(MHWs_comparison_lm, aes(x = intensity_cumulative, y = log_max_displacement)) +
  stat_summary(fun = mean, geom = "point", size = 3, color = "black") +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0.2, color = "black") +
  geom_smooth(method = "lm", se = TRUE, color = "darkred", linewidth = 1.4) +
  stat_poly_eq(
    aes(label = paste( ..rr.label.., ..p.value.label.., sep = "~~~")),
    formula = y ~ x,
    parse = TRUE,
    label.x = "center",
    label.y = 0.9,
    size = 6,
    color = "black"
  ) +
  scale_x_continuous(breaks = seq(0, 30, by = 5)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  # geom_text(data = n_df_act, aes(x = intensity_cumulative, y=Inf , label = n),
  #           inherit.aes = FALSE, size = 3, fontface = "bold",vjust=2) +
  # facet_wrap(~ Stage_period) +
  labs(
    x= "Cumulative Intensity [Â°C days]",
    y = "ln(Displacment ratio)"
  ) +
  theme_bw()+
  theme(panel.grid = element_blank(),
        axis.text = element_text(size = 18,color = "black"),
        axis.title = element_text(size = 20),
        axis.title.x = element_blank())


# Filter out rows with NA displacment
sum_heat_wave_disp <- sum_heat_wave_day %>%
  filter(!is.na(mean_disp_max)) %>% 
  select(fish_id,Serial,Before_After,mean_disp_max,sd_disp_max,disp_max_days,species) %>% distinct()

sum_heat_wave_disp$Serial_fish_id <- paste0(sum_heat_wave_disp$Serial,"_",sum_heat_wave_disp$fish_id) 
sum_heat_wave_disp$Serial_fish_id <- as.factor(sum_heat_wave_disp$Serial_fish_id)

# Plot
sum_heat_wave_disp <- sum_heat_wave_disp %>%
  mutate(
    x_pos = as.numeric(Before_After),  # e.g., Before=1, MHW=2, After=3
    x_jittered = x_pos + runif(n(), min = -0.1, max = 0.1)  # consistent jitter
  ) %>% 
  group_by(Serial_fish_id) %>%
  filter(n_distinct(Before_After) > 1) %>%
  ungroup()

n_counts_disp <- sum_heat_wave_disp %>%
  group_by(Before_After, x_pos) %>%
  summarise(n = n(), .groups = "drop")

disp_symbol_compare_plot <- ggplot(sum_heat_wave_disp) +
  geom_line(aes(x = x_jittered, y = mean_disp_max, group = Serial_fish_id),
            color = "grey60", alpha = 0.5, linewidth = 0.5) +
  geom_point(aes(x = x_jittered, y = mean_disp_max, fill = Before_After),
             shape = 21, size = 3, alpha = 0.5) +

  # geom_boxplot(aes(fill = Before_After),alpha = 0.7,show.legend = FALSE) +
  
  scale_fill_manual(values = c("Before" = "#2E8B57",
                               "MHW" = "#DC143C",
                               "After" = "#4169E1"))+
  scale_color_manual(values = c("Before" = "#2E8B57",
                              "MHW" = "#DC143C",
                              "After" = "#4169E1"))+
  # facet_wrap(~species,scales="free_y")+
  stat_summary(
    aes(x = x_pos, y = mean_disp_max),
    fun.data = function(x) {
      m <- mean(x)
      se <- sd(x) / sqrt(length(x))
      data.frame(
        y = m,
        ymin = m - 1.96 * se , 
        ymax = m + 1.96 * se   
      )
        },
    geom = "errorbar",
    width = 0.1,
    linewidth = 0.8,
    ) +
  # Add mean points and CI
  stat_summary(
    aes(x = x_pos, y = mean_disp_max, fill = Before_After),
    fun = mean,
    geom = "point",
    shape = 21, # Diamond shape
    size = 7,
    stroke=1.2
  ) +
  scale_x_continuous(
    breaks = c(1, 2, 3),
    labels = c("Before", "MHW", "After")
  ) +
  geom_text(
    data = n_counts_disp,
    aes(x = x_pos, y = max(sum_heat_wave_disp$mean_disp_max)+30, label = n),
    size = 5
  )+
  labs(
    x = "MHW Stage",
    y = "Mean max daily displacment [m]"
  ) +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        axis.text = element_text(size = 18,color = "black"),
        axis.title = element_text(size = 20),
        axis.title.x = element_blank())

ggsave("Red Sea/Results/Plots/disp_symb_compare_plot_species_OISST_Fix.svg", disp_symbol_compare_plot, width = 12, height = 10)

full_mean_plot <- 
  act_symbol_compare_plot+
  dep_symbol_compare_plot+
  disp_symbol_compare_plot

full_mean_plot
layout <- c(
  area(t = 1, l = 1, b = 1, r = 1),  # top-left (1/3 width)
  area(t = 1, l = 2, b = 1, r = 3),  # top-right (2/3 width)
  area(t = 2, l = 1, b = 2, r = 1),  # middle-left (1/3 width)
  area(t = 2, l = 2, b = 2, r = 3),  # middle-right (2/3 width)
  area(t = 3, l = 1, b = 3, r = 1),  # bottom-left (1/3 width)
  area(t = 3, l = 2, b = 3, r = 3)   # bottom-right (2/3 width)
)

# Combine with design layout
full_plot <- act_symbol_compare_plot + act_reg_plot +
             disp_symbol_compare_plot + disp_reg_plot +
             dep_symbol_compare_plot + dep_reg_plot +
             
             plot_layout(design = layout)

full_plot

ggsave("Red Sea/Results/Plots/act_dep_disp_compare_plot_OISST_Fix2.svg", full_plot, width = 12, height = 10)


```


### GAM
#### Data exploration
```{r}
### depth/activity/distance ~ time of day + Before.After + intensity mean/cummelative + random(fish_id) +random (MHW_ID)

# Generate an exploratory report for the combined dataset
DataExplorer::create_report(MHWs_combined_data)

# Arrange data and factor levels for analysis

MHWs_combined_data <- MHWs_combined_data %>% arrange(fish_id,real_datetime)
MHWs_combined_data$Before_After <- factor(MHWs_combined_data$Before_After, levels = c("Before","MHW","After"))

###### Activity Analysis
# Filter and clean data for activity-related variables
act_fish_df <- MHWs_combined_data %>%
  select(fish_id,real_datetime,activity,Before_After,Serial) %>% 
  na.omit()

# Count activity observations per fish and MHW event
act_counts_fish <- act_fish_df %>% 
  count(fish_id,Serial,Before_After)

# Visualize activity levels using boxplots, faceted by fish ID
ggplot(act_fish_df,aes(x=Before_After,y=activity))+
  geom_boxplot()+
  facet_wrap(~fish_id)
# Inspect distribution of activity using histograms
hist(act_fish_df$activity) # Overall distribution
hist(act_fish_df$activity[act_fish_df$Before_After == "Before"]) # Before MHW
hist(act_fish_df$activity[act_fish_df$Before_After == "MHW"]) # During MHW
hist(act_fish_df$activity[act_fish_df$Before_After == "After"]) # After MHW
#  A Tweedie distribution 

###### Depth Analysis
# Filter and clean data for depth-related variables
dep_fish_df <- MHWs_combined_data %>%
  select(fish_id,real_datetime,depth,Before_After,Serial) %>% 
  na.omit()
  
# Count depth observations per fish and MHW event
dep_counts_fish <- dep_fish_df %>% 
  count(fish_id,Serial,Before_After)

# Visualize depth levels using boxplots, faceted by fish ID
ggplot(dep_fish_df,aes(x=Before_After,y=depth))+
  geom_boxplot()+
  facet_wrap(~fish_id)

# Inspect distribution of depth using histograms
hist(dep_fish_df$depth) # Overall distribution
hist(dep_fish_df$depth[dep_fish_df$Before_After == "Before"]) # Before MHW
hist(dep_fish_df$depth[dep_fish_df$Before_After == "MHW"]) # During MHW
hist(dep_fish_df$depth[dep_fish_df$Before_After == "After"]) # After MHW
# Log transformation

##### Distance from Shore Analysis
# Filter and clean data for distance-related variables
dis_fish_df <- MHWs_combined_data %>%
  select(fish_id,real_datetime,distance_shore,Before_After,Serial) %>% 
  na.omit()

# Count distance observations per fish and MHW event
dis_counts_fish <- dis_fish_df %>% 
  count(fish_id,Serial,Before_After)

# Inspect distribution of distance from shore using histograms
hist(dis_fish_df$distance_shore) # Overall distribution
hist(dis_fish_df$distance_shore[dis_fish_df$Before_After == "Before"]) # Before MHW
hist(dis_fish_df$distance_shore[dis_fish_df$Before_After == "MHW"]) # During MHW
hist(dis_fish_df$distance_shore[dis_fish_df$Before_After == "After"]) # After MHW
# Note: Need centering and scaling this variable for modeling

#### Collinearity Check
# Select numerical predictors for visualizatio
col_num_vis <- MHWs_combined_data %>% select(activity,depth,distance_shore,intensity_mean,intensity_max,intensity_cumulative,duration,rate_onset,rate_decline)

# Generate pairwise scatterplots to assess collinearity
pairs(col_num_vis,cex.labels = 1)

```
#### Find the three top MHWs and isolated MHWs
```{r}
names(MHWs_Eilat) <- make.names(names(MHWs_Eilat), unique = TRUE)

# Filter MHWs that have fish IDs (i.e., not NA)
MHWs_Eilat_filtered <- MHWs_Eilat %>%
  filter(!is.na(Fish_IDs))


# Define the categories to find top 3 values
categories <- c("intensity_max", "intensity_mean", "intensity_cumulative", 
                "intensity_max_abs", "rate_onset", "duration")

# Create a new dataframe with top 3 MHWs per category
top_MHWs <- bind_rows(
  lapply(categories, function(cat) {
    MHWs_Eilat_filtered %>%
      arrange(desc(!!sym(cat))) %>%  # Sort by category in descending order
      slice_head(n = 3) %>%          # Select top 3
      mutate(category_top = cat)         # Add category name
  })
)

# Filter for 'isolated_MHW' where reliability level is 'T' in levels 2 or 3
isolated_MHWs <- MHWs_Eilat_filtered %>%
  filter(reliabaility.level.2=="T" & reliabaility.level.3=="T") %>%
  mutate(category_top = "isolated_MHW")  # Assign "isolated_MHW" as the category

# Combine 'isolated_MHW' with the top MHWs for other categories
top_MHWs <- bind_rows(top_MHWs, isolated_MHWs)

# Relocate the 'category_top' column to the front (before 'Serial')
top_MHWs <- top_MHWs %>% relocate(category_top,.before = Serial)

# Nest the dataframe by 'category_top'
top_MHWs <- top_MHWs %>% nest_by(category_top)

saveRDS(top_MHWs,"Red Sea/Results/Models/top_MHWs_OISST_Fix.rds")
```


#### Create dataframe for GAM and daily curves
```{r}
####### choose which data set to work on through MHWs_Eilat  ###########
MHWs_fish_data <- get_MHW_fish_df(MHWs_Eilat)
  
```

#### Depth Models 
```{r}
hist(MHWs_fish_data$depth)

MHWs_fish_data$Serial_fish_id <- paste0(MHWs_fish_data$Serial,"_",MHWs_fish_data$fish_id)
MHWs_fish_data$Serial_fish_id <- as.factor(MHWs_fish_data$Serial_fish_id)
MHWs_fish_data <- MHWs_fish_data %>% relocate(Serial_fish_id,.after = fish_id)

# Log-transform depth to address skewness in distribution
MHWs_fish_data$log_depth <- log(MHWs_fish_data$depth + 1)
hist(MHWs_fish_data$log_depth) # Check distribution post-transformation

# Remove Serial_fish_id levels that have only NA values for depth
MHWs_fish_data_dep_filtered <- MHWs_fish_data %>%
  filter(!is.na(depth))

print(paste("number of fish before filter:",length(unique(MHWs_fish_data_dep_filtered$Serial_fish_id))))
print(paste("number of MHWs before filter:",length(unique(MHWs_fish_data_dep_filtered$Serial))))


# Add an "hour" column
MHWs_fish_data_dep_filtered <- MHWs_fish_data_dep_filtered %>%
  mutate(hour = hour(real_datetime)) 

# Count the number of data points per date for each Serial_fish_id
hourly_depth_counts <-  MHWs_fish_data_dep_filtered %>% 
  group_by(Serial_fish_id,date,hour,Before_After,species) %>% 
  summarise(n=n(), .groups = "drop")

# Compute the mean number of data points per Serial_fish_id
mean_counts <- hourly_depth_counts %>%
  group_by(Serial_fish_id) %>%
  summarise(mean_count = mean(n),
                        prop_high_activity = mean(n > 2), .groups = "drop")


# Plot histogram 
ggplot(hourly_depth_counts, aes(x = n)) +
  geom_histogram(binwidth = 1, fill = "steelblue", color = "black", alpha = 0.7) +
  facet_wrap(~Serial_fish_id, scales = "free") +  # Facet by fish ID
  labs(title = "Hourly Counts per Serial Fish ID with Mean",
       x = "Hourly Data Count",
       y = "Frequency") +
  theme_minimal()


# Filter out Serial_fish_id values with mean count less than 2 detections per hour mean
MHWs_fish_data_dep_filtered <- MHWs_fish_data_dep_filtered %>%
  filter(Serial_fish_id %in% mean_counts$Serial_fish_id[mean_counts$mean_count >= 2])
points_per_stage <- MHWs_fish_data_dep_filtered %>%
  group_by(Before_After, Serial_fish_id) %>%
  summarise(n = n()) %>%
  ungroup()

# Filter out MHW stages with less than 50 points
filtered_points_per_stage <- points_per_stage %>%
  filter(n >= 100)

# Find Serial_fish_ids that have only one stage left after filtering
fish_to_remove <- filtered_points_per_stage %>%
  group_by(Serial_fish_id) %>%
  summarise(stages_count = n_distinct(Before_After)) %>%
  filter(stages_count == 1) %>%
  pull(Serial_fish_id)

# Filter the original dataset based on the remaining stages and exclude the fish with only one stage
MHWs_fish_data_dep_filtered <- MHWs_fish_data_dep_filtered %>%
  filter(Serial_fish_id %in% filtered_points_per_stage$Serial_fish_id) %>%
  filter(!(Serial_fish_id %in% fish_to_remove))

print(paste("number of fish after filter:",length(unique(MHWs_fish_data_dep_filtered$Serial_fish_id))))
print(paste("number of MHWs after filter:",length(unique(MHWs_fish_data_dep_filtered$Serial))))

# Create the histogram plot with facets for each Serial_fish_id
ggplot(MHWs_fish_data_dep_filtered, aes(x = log_depth)) +
  geom_histogram(binwidth = 0.1, fill = "skyblue", color = "black", alpha = 0.7) +
  facet_wrap(~ Serial_fish_id, scales = "free") +
  theme_minimal() +
  labs(
    title = "Histogram of log depth for Each Serial Fish ID",
    x = "Log Depth",
    y = "Count"
  ) +
  theme(
    strip.text = element_text(size = 10, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

# Create the timeline plot with facets for each Serial_fish_id
ggplot(MHWs_fish_data_dep_filtered,aes(x=real_datetime,y=depth))+
  geom_rect(
    aes(xmin = date_start, xmax = date_end, ymin = -Inf, ymax = Inf),
    fill = "red", alpha = 0.2
  ) +
  geom_point() +
  theme_minimal() +
  scale_y_reverse()+
  facet_wrap(~ Serial_fish_id,scales="free")+
  labs(
    title = "Time series of depth for Each Serial Fish ID",
    x = "Time",
    y = "Depth"
  ) 



stage_effect <- predict_response(simple_model_dep, terms = c("DecimalTimeOfDay","Before_After"))
stage_effect$predicted <- exp(stage_effect$predicted)  # Back-transform predictions
stage_effect$conf.low <- exp(stage_effect$conf.low)    # Back-transform lower CI
stage_effect$conf.high <- exp(stage_effect$conf.high)  # Back-transform upper CI
ggplot(stage_effect, aes(x = x, y = predicted, color = group)) +
  geom_line() +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = group), alpha = 0.2) +
  scale_y_reverse()+
  theme_bw()+
    ylab("Depth")+
    xlab("Time of day")+
    scale_color_manual(values = c("MHW" = "red", "After" = "green", "Before" = "blue")) +
    scale_fill_manual(values = c("MHW" = "red", "After" = "green", "Before" = "blue")) 





results_depths <- automate_model_selection(MHWs_fish_data_dep_filtered, response_var = "log_depth", family = gaussian())
appraise(results_depths$all_models$with_MHW[[4]])
summary(results_depths$all_models$with_MHW[[4]])
gratia::draw(results_depths$all_models$with_MHW[[4]])
# Compute the difference between two stages:
diff_bf_mhw <- difference_smooths(results_depths$all_models$with_MHW[[4]], smooth = "DecimalTimeOfDay", by = c("Before", "MHW"))
draw(diff_bf_mhw)



emm <- emmeans(results_depths$best_model, ~ Before_After)

daily_stage_effect <- predict_response(results_depths$best_model, terms = c("DecimalTimeOfDay","Before_After"),margin="simulate")
print(daily_stage_effect)
daily_stage_effect$predicted <- exp(daily_stage_effect$predicted)  # Back-transform predictions
daily_stage_effect$conf.low <- exp(daily_stage_effect$conf.low)    # Back-transform lower CI
daily_stage_effect$conf.high <- exp(daily_stage_effect$conf.high)  # Back-transform upper CI
plot(daily_stage_effect) 
ggplot(daily_stage_effect,aes(x=x,y=predicted))+
  geom_line(aes(color=group))+
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = group), alpha = 0.2) +  # Confidence intervals
   scale_y_reverse()+
  theme_bw()+
    ylab("Depth [m]")+
    xlab("Time of day")+
    labs(title= "Predicted values of depth")+
    scale_color_manual(values = c("MHW" = "red", "After" = "green", "Before" = "blue")) +
    scale_fill_manual(values = c("MHW" = "red", "After" = "green", "Before" = "blue")) 



ind_stage_effect <- predict_response(results_depths$best_model, terms = c("DecimalTimeOfDay","Before_After","Serial_fish_id"))
print(ind_stage_effect)
ind_stage_effect$predicted <- exp(ind_stage_effect$predicted)  # Back-transform predictions
ind_stage_effect$conf.low <- exp(ind_stage_effect$conf.low)    # Back-transform lower CI
ind_stage_effect$conf.high <- exp(ind_stage_effect$conf.high)  # Back-transform upper CI
ggplot(ind_stage_effect,aes(x=x,y=predicted))+
  geom_line(aes(color=group))+
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = group), alpha = 0.2) +  # Confidence intervals
   scale_y_reverse()+
  facet_wrap(~facet)+
  theme_bw()+
    ylab("Depth [m]")+
    xlab("Time of day")+
    labs(title= "Predicted values of depth")+
    scale_color_manual(values = c("MHW" = "red", "After" = "green", "Before" = "blue")) +
    scale_fill_manual(values = c("MHW" = "red", "After" = "green", "Before" = "blue")) 

stage_effect_only <- predict_response(results_depths$best_model, terms = c("Before_After"),margin="empirical")
stage_effect_only$predicted <- exp(stage_effect_only$predicted)  # Back-transform predictions
stage_effect_only$conf.low <- exp(stage_effect_only$conf.low)    # Back-transform lower CI
stage_effect_only$conf.high <- exp(stage_effect_only$conf.high)  # Back-transform upper CI
print(stage_effect_only)
ggplot(stage_effect_only, aes(x=x, y = predicted)) +
  geom_point() +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), width = 0.2)+
  theme_bw()+
    ylab("Predicted Depth [m]")+
    xlab("MHW stage")


if ("species" %in% all.vars(formula(model))) {
  Plot_with_species(results_depths$best_model,MHWs_fish_data_dep_filtered)
} else
{
  # Plot_with_individuals(results_depths$best_model,MHWs_fish_data_dep_filtered)
  # x <- predict_gam(results_depths$best_model,length_out = 24,exclude_terms = "s(Serial_fish_Id,bs='re')")
  # plot(x,"DecimalTimeOfDay","Before_After")
  dep_pred <- tidymv::get_gam_predictions(results_depths$best_model,series = DecimalTimeOfDay,exclude_random = F,transform = exp,exclude_terms = "s(Serial_fish_id)")
  smooth_values <- plot_smooths(results_depths$best_model, series = DecimalTimeOfDay, comparison = Before_After,facet_terms = Serial_fish_id)

  # Back-transformation
  smooth_values$data$log_depth <- exp(smooth_values$data$log_depth) - 1
  smooth_values$data$CI_upper <- exp(smooth_values$data$CI_upper) - 1
  smooth_values$data$CI_lower <- exp(smooth_values$data$CI_lower) - 1

  smooth_values+
    theme(legend.position = "top") +
    theme_bw() +
    scale_color_manual(values = c("MHW" = "red", "After" = "green", "Before" = "blue")) +
    scale_fill_manual(values = c("MHW" = "red", "After" = "green", "Before" = "blue")) +
    # Optional: Adjust transparency of the CI fill (alpha)
    scale_y_reverse()+
    ylab("Depth [m]")+
    xlab("Time of day")
}
saveRDS(results_depths,"Red Sea/Results/Models/Depth_Models_Amazia_Fixbase.RDS")

```
#### Activity models
```{r}

hist(MHWs_fish_data$activity) # Check activity distribution 
# Remove Serial_fish_id levels that have only NA values for standerized_distance
MHWs_fish_data_act_filtered <- MHWs_fish_data %>%
  filter(!is.na(activity))

print(paste("number of fish before filter:", length(unique(MHWs_fish_data_act_filtered$Serial_fish_id))))
print(paste("number of MHWs before filter:",length(unique(MHWs_fish_data_act_filtered$Serial))))

# Add an "hour" column
MHWs_fish_data_act_filtered <- MHWs_fish_data_act_filtered %>%
  mutate(hour = hour(real_datetime)) 

# Count the number of data points per date for each Serial_fish_id
hourly_act_counts <-  MHWs_fish_data_act_filtered %>% 
  group_by(Serial_fish_id,date,hour,Before_After,species) %>% 
  summarise(n=n(), .groups = "drop")

# Compute the mean number of data points per Serial_fish_id
mean_counts <- hourly_act_counts %>%
  group_by(Serial_fish_id) %>%
  summarise(mean_count = mean(n),
            prop_high_activity = mean(n > 2),.groups = "drop")

# Boxplot
ggplot(hourly_depth_counts, aes(x = as.factor(Serial_fish_id), y = n)) +
    geom_boxplot(fill = "lightblue", color = "black") +
    labs(title = "Boxplot of Hourly Counts per Serial Fish ID",
         x = "Serial Fish ID",
         y = "Hourly Data Count") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))  # Rotate x-axis labels for readability

# Plot histogram 
ggplot(hourly_depth_counts, aes(x = n)) +
  geom_histogram(binwidth = 1, fill = "steelblue", color = "black", alpha = 0.7) +
  facet_wrap(~Serial_fish_id, scales = "free") +  # Facet by fish ID
  labs(title = "Hourly Counts per Serial Fish ID with Mean",
       x = "Hourly Data Count",
       y = "Frequency") +
  theme_minimal()

# Filter out Serial_fish_id values with mean count less than 4 detections per hour mean
MHWs_fish_data_act_filtered <- MHWs_fish_data_act_filtered %>%
  filter(Serial_fish_id %in% mean_counts$Serial_fish_id[mean_counts$mean_count >= 2]) 

# Compute the number of data points per MHW stage
points_per_stage <- MHWs_fish_data_act_filtered %>%
  group_by(Before_After, Serial_fish_id) %>%
  summarise(n = n()) %>%
  ungroup()

# Filter out MHW stages with less than 50 points
filtered_points_per_stage <- points_per_stage %>%
  filter(n >= 100)

# Find Serial_fish_ids that have only one stage left after filtering
fish_to_remove <- filtered_points_per_stage %>%
  group_by(Serial_fish_id) %>%
  summarise(stages_count = n_distinct(Before_After)) %>%
  filter(stages_count == 1) %>%
  pull(Serial_fish_id)

# Filter the original dataset based on the remaining stages and exclude the fish with only one stage
MHWs_fish_data_act_filtered <- MHWs_fish_data_act_filtered %>%
  filter(Serial_fish_id %in% filtered_points_per_stage$Serial_fish_id) %>%
  filter(!(Serial_fish_id %in% fish_to_remove))


print(paste("number of fish after filter:",length(unique(MHWs_fish_data_act_filtered$Serial_fish_id))))
print(paste("number of MHWs after filter:",length(unique(MHWs_fish_data_act_filtered$Serial))))



# Create the histogram plot with facets for each Serial_fish_id
ggplot(MHWs_fish_data_act_filtered, aes(x = activity)) +
  geom_histogram(binwidth = 0.1, fill = "skyblue", color = "black", alpha = 0.7) +
  facet_wrap(~ Serial_fish_id, scales = "free_y") +
  theme_minimal() +
  labs(
    title = "Histogram of Activity for Each Serial Fish ID",
    x = "Activity",
    y = "Count"
  ) +
  theme(
    strip.text = element_text(size = 10, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
# Create the timeline plot with facets for each Serial_fish_id
ggplot(MHWs_fish_data_act_filtered, aes(x=real_datetime,y = activity)) +
  geom_point(fill = "skyblue", color = "black", alpha = 0.7) +
  facet_wrap(~ Serial_fish_id, scales = "free") +
  theme_minimal() +
  labs(
    title = "Time series of activity for Each Serial Fish ID",
    x = "Time",
    y = "Activity"
  ) +
  theme(
    strip.text = element_text(size = 10, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  ) 

results_activity <- automate_model_selection(MHWs_fish_data_act_filtered, response_var = "activity", family = "tw")

#diagnsotic plots for the winning
appraise(results_activity$best_model)
summary(results_activity$best_model)

# Generate full prediction grid
new_data <- expand.grid(
  DecimalTimeOfDay = seq(0, 24, length.out = 100),  # Predict across a full day
  Serial_fish_id = unique(MHWs_fish_data_act_filtered$Serial_fish_id),  # All fish
  Before_After = c("Before", "MHW", "After")  # All conditions
)

# Keep only valid combinations that exist in the actual data
existing_combinations <- MHWs_fish_data_act_filtered %>%
  distinct(Serial_fish_id, Before_After)
new_data <- new_data %>%
  semi_join(existing_combinations, by = c("Serial_fish_id", "Before_After"))

# Predict for valid combinations only
new_data$predicted_activity <- predict(results_activity$best_model, newdata = new_data, type = "response", se.fit = TRUE)$fit
new_data$se <- predict(results_activity$best_model, newdata = new_data, type = "response", se.fit = TRUE)$se.fit

# Plot the predicted activity with 95% CI ribbons
ggplot(new_data, aes(x = DecimalTimeOfDay, y = predicted_activity, color = Before_After)) +
  geom_line() +
  geom_ribbon(aes(ymin = predicted_activity - 1.96 * se, ymax = predicted_activity + 1.96 * se, fill = Before_After), alpha = 0.3) +
  facet_wrap(~ Serial_fish_id,scales="free_y") +
  theme_minimal() +
  labs(title = "Predicted Fish Activity Across Time of Day",
       x = "Time of Day",
       y = "Predicted Activity")+
    scale_color_manual(values = c("MHW" = "red", "After" = "green", "Before" = "blue")) +
    scale_fill_manual(values = c("MHW" = "red", "After" = "green", "Before" = "blue")) 

if ("species" %in% all.vars(formula(model))) {
Plot_with_species(results_activity$best_model,MHWs_fish_data_act_filtered)
} else
{
plot_smooths(results_activity$best_model, series = DecimalTimeOfDay, comparison = Before_After) + 
  theme(legend.position = "top") + 
  theme_bw() +
  scale_color_manual(values = c("MHW" = "red", "After" = "green", "Before" = "blue")) + 
  scale_fill_manual(values = c("MHW" = "red", "After" = "green", "Before" = "blue")) +
  # Optional: Adjust transparency of the CI fill (alpha)
  theme(legend.position = "top")
}


saveRDS(results_activity,"Red Sea/Results/Models/Act_Models_OISST_detrended_Jacox.RDS")


```

#### Distance models
```{r}

# Filter unique Serial_fish_id with non-NA distance data
unique_fish_with_distance <- MHWs_fish_data %>%
  filter(!is.na(distance_shore)) %>%  # Keep only rows with non-NA distance
  distinct(Serial_fish_id)        # Get unique Serial_fish_id
print(unique_fish_with_distance)

# Create a column with the time of the day
MHWs_fish_data$TimeOfDay <- as.POSIXct(format(MHWs_fish_data$real_datetime,format = "%H:%M:%S"),format = "%H:%M:%S")

# Convert time of day to decimal format for modeling
MHWs_fish_data$DecimalTimeOfDay <- time_to_decimal(MHWs_fish_data$TimeOfDay) 

# Convert Before_after to factor and create new factor for combined MHW serial and fish id
MHWs_fish_data$Serial_fish_id <- paste(MHWs_fish_data$Serial,MHWs_fish_data$fish_id,sep="_")
MHWs_fish_data$Serial_fish_id <- as.factor(MHWs_fish_data$Serial_fish_id)
MHWs_fish_data$Before_After <- as.factor(MHWs_fish_data$Before_After)

hist(MHWs_fish_data$standerized_distance) # Check distance distribution 

# Remove Serial_fish_id levels that have only NA values for standerized_distance
MHWs_fish_data_distance_filtered <- MHWs_fish_data %>%
  filter(!is.na(standerized_distance))
# Create the histogram plot with facets for each Serial_fish_id
ggplot(MHWs_fish_data_distance_filtered, aes(x = standerized_distance)) +
  geom_histogram(binwidth = 0.1, fill = "skyblue", color = "black", alpha = 0.7) +
  facet_wrap(~ Serial_fish_id, scales = "free_y") +
  theme_minimal() +
  labs(
    title = "Histogram of Standardized Distance for Each Serial Fish ID",
    x = "Standardized Distance",
    y = "Count"
  ) +
  theme(
    strip.text = element_text(size = 10, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )


# Distance models without MHW effect
dis_mod_no_MHW_GS <- bam(
          standerized_distance ~ s(DecimalTimeOfDay, bs = 'cc', m = 2) + s(DecimalTimeOfDay, by = Serial_fish_id, bs = 'cc', m = 1) , data = MHWs_fish_data_distance_filtered, method = "REML", family = gaussian())
dis_mod_no_MHW_S <- bam(
          standerized_distance ~  s(DecimalTimeOfDay, by = Serial_fish_id, bs = 'cc'), data = MHWs_fish_data_distance_filtered, method = "REML", family = gaussian())
dis_mod_no_MHW_GI <- bam(
          standerized_distance ~ s(DecimalTimeOfDay, bs = 'cc', m = 2) + s(DecimalTimeOfDay, by = Serial_fish_id, bs = 'cc', m = 1) + s(Serial_fish_id, bs = "re") ,data = MHWs_fish_data_distance_filtered, method = "REML", family = gaussian())
dis_mod_no_MHW_I <-bam(
          standerized_distance ~  s(DecimalTimeOfDay, by = Serial_fish_id, bs = 'cc') + s(Serial_fish_id, bs = "re"),data = MHWs_fish_data_distance_filtered, method = "REML", family = gaussian())


dis_models_no_MHW <- list(
  dis_mod_no_MHW_GS,dis_mod_no_MHW_S,dis_mod_no_MHW_GI, dis_mod_no_MHW_I
)
performance::compare_performance(dis_models_no_MHW, rank = TRUE)
##I wins

# Without global and with smooth for Before_after
# shared wiggliness
dis_mod_Is <- bam(
          standerized_distance ~ s(DecimalTimeOfDay, by = Serial_fish_id, bs = 'cc') + s(Serial_fish_id, bs = "re") + s(DecimalTimeOfDay, by = Before_After, bs = 'cc'),data = MHWs_fish_data_distance_filtered, method = "REML", family = gaussian())

# Without global and without smooth for Before_after
# Differed wiggliness
dis_mod_I <- bam(
          standerized_distance ~ s(DecimalTimeOfDay, by = Serial_fish_id, bs = 'cc') + s(Serial_fish_id, bs = "re") + Before_After,data = MHWs_fish_data_distance_filtered, method = "REML", family = gaussian())

comparison_dis_models <- list(
  dis_mod_no_MHW_I,dis_mod_I,dis_mod_Is
)

performance::compare_performance(comparison_dis_models, rank = TRUE)
# dis_mod_Is wins
appraise(dis_mod_Is)

#Population - level
plot_smooths(dis_mod_Is, series = DecimalTimeOfDay, comparison = Before_After) + 
  theme(legend.position = "top") + 
  theme_bw() +
  scale_color_manual(values = c("MHW" = "red", "After" = "green", "Before" = "blue")) + 
  scale_fill_manual(values = c("MHW" = "red", "After" = "green", "Before" = "blue")) +
  # Optional: Adjust transparency of the CI fill (alpha)
  theme(legend.position = "top")

#Individual - level
plot_smooths(act_mod_Is, series = DecimalTimeOfDay, comparison = Before_After,facet_terms = Serial_fish_id) + 
  theme(legend.position = "top") + 
  theme_bw() +
  scale_color_manual(values = c("MHW" = "red", "After" = "green", "Before" = "blue")) + 
  scale_fill_manual(values = c("MHW" = "red", "After" = "green", "Before" = "blue")) +
  # Optional: Adjust transparency of the CI fill (alpha)
  theme(legend.position = "top")


model_formulas <- lapply(depth_models, formula)

model_selection <- data.frame(
  Model = character(),
  AIC = numeric(),
  BIC = numeric(),
  stringsAsFactors = FALSE
)

# Loop over all models
for (i in seq_along(depth_models)) {
  model <- depth_models[[i]]
  model_name <- model_formulas[i]
  
  # Extract metrics
  aic <- AIC(model)
  bic <- BIC(model)

  # Add to the results table
  model_selection <- rbind(model_selection, 
                           data.frame(Model = as.character(model_name), AIC = aic, BIC = bic))
}

# Sort by AIC (or BIC) to find the best model
model_selection <- model_selection[order(model_selection$AIC), ]


act_models <- list(act_mod_no_MHW_GI,act_mod_no_MHW_GS,act_mod_no_MHW_I,act_mod_no_MHW_S,act_mod_S,act_mod_I,act_mod_Is)
saveRDS(act_models,"Red Sea/Results/Act_Models.RDS")


```


# Not sure if necessary
### Models
```{r}
# Create a column with the time of the day
MHWs_fish_data$TimeOfDay <- as.POSIXct(format(MHWs_fish_data$real_datetime,format = "%H:%M:%S"),format = "%H:%M:%S")

# Convert time of day to decimal format for modeling
MHWs_fish_data$DecimalTimeOfDay <- time_to_decimal(MHWs_fish_data$TimeOfDay) 

# Convert fish_id and Before_after to factor
MHWs_fish_data$fish_id <- as.factor(MHWs_fish_data$fish_id)
MHWs_fish_data$Before_After <- as.factor(MHWs_fish_data$Before_After)

# Create unique identifiers for combinations of MHW Serial and Fish ID
MHWs_fish_data$MHW_Serial_Fish_Id <- paste(MHWs_fish_data$Serial, MHWs_fish_data$fish_id)
MHWs_fish_data$MHW_Serial_Fish_Id <- as.factor(MHWs_fish_data$MHW_Serial_Fish_Id)

# Create unique identifiers for combinations of MHW Serial, Fish ID, and Before/After stages
MHWs_fish_data$MHW_Serial_Fish_Id_Befoe_After <- paste(MHWs_fish_data$MHW_Serial_Fish_Id, MHWs_fish_data$Before_After)
MHWs_fish_data$MHW_Serial_Fish_Id_Befoe_After <- as.factor(MHWs_fish_data$MHW_Serial_Fish_Id_Befoe_After)

# Log-transform depth to address skewness in distribution
MHWs_fish_data$log_depth <- log(MHWs_fish_data$depth + 1) 
hist(MHWs_fish_data$log_depth) # Check distribution post-transformation

### Generalized Additive Models (GAMs)

## Activity
# Global GAM for activity with a cyclic spline for time of day and random effects for fish ID
G_activity_gam <- gam(activity ~ s(DecimalTimeOfDay,k=25,bs="cc")+s(fish_id, bs="re"),data=MHWs_fish_data, method="REML", family="tw")
draw(G_activity_gam)  # Visualize model fit
plot(G_activity_gam)
summary(G_activity_gam) # Summary of the model
mgcv::gam.check(G_activity_gam) # Diagnostics
gratia::appraise(G_activity_gam) # Additional diagnostics

# GAM with interaction: Time of day and Before/After stages
GS_activity_gam <- bam(activity ~ s(DecimalTimeOfDay,by=Before_After,bs="cc") + Before_After +s(fish_id, bs="re"),data=MHWs_fish_data, method="REML", family="tw")
draw(GS_activity_gam)
mgcv::plot.gam(GS_activity_gam)
summary(GS_activity_gam)
mgcv::gam.check(GS_activity_gam)

# Visualize smooth terms with respect to Before/After stages
plot_smooths(GS_activity_gam,series = DecimalTimeOfDay,comparison = Before_After)+
  theme(legend.position = "top")+
  theme_bw()

## Distance from Shore

# GAM for standardized distance with cyclic spline for time of day and random effects for fish ID
S_distance_gam <- bam(standerized_distance ~ s(DecimalTimeOfDay, by = Before_After, bs = "cc") + 
                        s(fish_id, bs = "re"), data = MHWs_fish_data, method = "REML", family = "gaussian")
draw(S_distance_gam)
mgcv::gam.check(S_distance_gam)
gratia::appraise(S_distance_gam)
summary(S_distance_gam)

# Visualize smooth terms
plot_smooths(S_distance_gam, series = DecimalTimeOfDay, comparison = Before_After) +
  theme(legend.position = "top") + theme_bw()

## Depth

# GAM for depth with interaction between time of day and fish ID
G_depth_gam <- bam(depth ~ s(DecimalTimeOfDay,bs="cc") + s(DecimalTimeOfDay,by = MHW_Serial_Fish_Id, bs="cc"),data=MHWs_fish_data, method="REML", family="gaussian")
summary(G_depth_gam)
gam.check(G_depth_gam)
# Visualize smooths for depth
plot_smooths(G_depth_gam, series = DecimalTimeOfDay, comparison = MHW_Serial_Fish_Id) +
  theme(legend.position = "top") + theme_bw() + scale_y_reverse()

# Depth model with Before/After stages included
G_depth_Bef.Aft_gam <- bam(depth ~ s(DecimalTimeOfDay, by = Before_After, bs = "cc") + 
                             s(DecimalTimeOfDay, by = MHW_Serial_Fish_Id_Befoe_After, bs = "cc"), 
                           data = MHWs_fish_data, method = "REML", family = "gaussian")
summary(G_depth_Bef.Aft_gam)
gam.check(G_depth_Bef.Aft_gam)

# Visualization
plot_smooths(G_depth_Bef.Aft_gam, series = DecimalTimeOfDay, comparison = Before_After) +
  theme(legend.position = "top") + theme_bw() + scale_y_reverse()

# Depth model with simpler interaction terms
G_depth_Bef.Aft1_gam <- bam(depth ~ s(DecimalTimeOfDay, by = Before_After, bs = "cc") + 
                              s(DecimalTimeOfDay, by = MHW_Serial_Fish_Id, bs = "cc"), 
                            data = MHWs_fish_data, method = "REML", family = "gaussian")
summary(G_depth_Bef.Aft1_gam)
gam.check(G_depth_Bef.Aft1_gam)

# Depth model with Before/After interaction and random fish effects
S_depth_gam <- bam(depth ~ s(DecimalTimeOfDay, by = Before_After, bs = "cc") + 
                     s(fish_id, bs = "re"), data = MHWs_fish_data, method = "REML", family = "nb")
summary(S_depth_gam)
mgcv::gam.check(S_depth_gam)
draw(S_distance_gam) 
gratia::appraise(S_depth_gam)

# Visualize smooths
plot_smooths(S_depth_gam, series = DecimalTimeOfDay, comparison = Before_After) +
  theme(legend.position = "top") + theme_bw() + scale_y_reverse()

# Create a dataframe to generate predictions
new_data <- expand.grid(
  DecimalTimeOfDay = seq(0, 24, length.out = 100),  # Generate 100 equally spaced time points from 0 to 24
  Before_After = factor(c("Before", "MHW", "After"),  # Specify levels of the factor variable 'Before_After'
                        levels = levels(MHWs_fish_data$Before_After)),  # Match the levels in the original data
  fish_id = levels(MHWs_fish_data$fish_id)  # Include all unique fish IDs from the original dataset
)

# Generate predictions using the fitted GAM model
predictions <- predict(
  S_depth_gam,                 # The GAM model
  newdata = new_data,          # Dataframe containing the values for prediction
  type = "response",           # Predict on the response scale
  se.fit = TRUE                # Return standard errors for predictions
)

# Add predicted depth values and confidence intervals to the new_data dataframe
new_data$predicted_depth <- predictions$fit  # Predicted values
new_data$lower_ci <- new_data$predicted_depth - 1.96 * predictions$se.fit  # Lower 95% CI
new_data$upper_ci <- new_data$predicted_depth + 1.96 * predictions$se.fit  # Upper 95% CI

# Plot the predicted depth over time
ggplot(new_data, aes(x = DecimalTimeOfDay, y = predicted_depth, colour = Before_After, group = Before_After)) +
  geom_line() +  # Add lines for predicted depth
  geom_ribbon(aes(ymin = lower_ci, ymax = upper_ci, fill = Before_After), alpha = 0.2, colour = NA) +
  # Add confidence intervals as shaded ribbons
  facet_wrap(~fish_id, scales = "free_y") +  # Create separate panels for each fish ID, allowing y-axis to vary
  theme_bw() +  # Use a clean black-and-white theme
  labs(
    x = "Time of Day (Decimal)",  # Label for the x-axis
    y = "Predicted Depth",        # Label for the y-axis
    title = "Predicted Depth Over Time by MHW Stage for Each Fish ID"  # Plot title
  ) +
  theme(
    legend.position = "top",             # Position legend at the top
    strip.text = element_text(size = 8)  # Reduce font size for facet labels to accommodate many fish IDs
  )+
  scale_y_reverse()

```
## Calculate means before and after the heat wave - wide
```{r}
MHWs_comparison <- data.frame(
  fish_id=numeric(),
  Serial=numeric(),
  window_factor=numeric(),
  Period_of_day=character(),
  ln_activity_ratio_bef_dur=numeric(),
  ln_activity_ratio_dur_aft=numeric(),
  ln_activity_ratio_bef_aft=numeric(),
  delta_depth_bef_dur=numeric(),
  delta_depth_dur_aft=numeric(),
  delta_depth_bef_aft=numeric(),
  delta_distance_bef_dur=numeric(),
  delta_distance_dur_aft=numeric(),
  delta_distance_bef_aft=numeric())

for (event_calc in 1:dim(nest_hw)[1]) {
  temp_heat_wave <- nest_hw$data[[event_calc]]
  # If contains date
  # temp_heat_wave <- temp_heat_wave %>%
  #   rename("activity" = "activity_mean",
  #          "depth" = "depth_mean",
  #          "distance_shore" = "distance_shore_mean") %>%
  #   group_by(fish_id,Before_After,Check_period)
  # # %>%
  #   summarise_at(vars(activity,depth,distance_shore),funs(mean(.,na.rm=T), median(.,na.rm=T),
  #                                                       sd(.,na.rm=T),n()))
  # 
  #With period
  for (fish in unique(temp_heat_wave$fish_id)) {
    temp_fish <- temp_heat_wave %>% filter(fish_id==fish)
    for (period in unique(temp_heat_wave$Period)) {
      temp_period <- temp_fish %>% filter(Period==period)
      temp_row <- data.frame(
                  fish_id=fish,
                  Serial=nest_hw$Serial[[event_calc]],
                  window_factor=nest_hw$window_factor[[event_calc]],
                  Period_of_day=period,
                  ln_activity_ratio_bef_dur=NA,
                  ln_activity_ratio_dur_aft=NA,
                  ln_activity_ratio_bef_aft=NA,
                  delta_depth_bef_dur=NA,
                  delta_depth_dur_aft=NA,
                  delta_depth_bef_aft=NA,
                  delta_distance_bef_dur=NA,
                  delta_distance_dur_aft=NA,
                  delta_distance_bef_aft=NA)
                  if(dim(temp_period[temp_period$Before_After=="MHW",])[1]>0
                     &dim(temp_period[temp_period$Before_After=="Before",])[1]>0)
                  {
                    temp_row$ln_activity_ratio_bef_dur <- log(temp_period$activity_mean[temp_period$Before_After=="MHW"] /temp_period$activity_mean[temp_period$Before_After=="Before"])
                    temp_row$delta_depth_bef_dur <- temp_period$depth_mean[temp_period$Before_After=="MHW"] - temp_period$depth_mean[temp_period$Before_After=="Before"]
                    temp_row$delta_distance_bef_dur <- abs(temp_period$distance_shore_mean[temp_period$Before_After=="MHW"]- temp_period$distance_shore_mean[temp_period$Before_After=="Before"])
                  }
                  if(dim(temp_period[temp_period$Before_After=="MHW",])[1]>0
                      &dim(temp_period[temp_period$Before_After=="After",])[1]>0)
                  {
                     temp_row$ln_activity_ratio_dur_aft <- log(temp_period$activity_mean[temp_period$Before_After=="After"]/temp_period$activity_mean[temp_period$Before_After=="MHW"])
                     temp_row$delta_depth_dur_aft <- temp_period$depth_mean[temp_period$Before_After=="After"] - temp_period$depth_mean[temp_period$Before_After=="MHW"]
                     temp_row$delta_distance_dur_aft <-
                     abs(temp_period$distance_shore_mean[temp_period$Before_After=="After"] - temp_period$distance_shore_mean[temp_period$Before_After=="MHW"])
                  }
                  if(dim(temp_period[temp_period$Before_After=="Before",])[1]>0
                      &dim(temp_period[temp_period$Before_After=="After",])[1]>0)
                  {
                    temp_row$ln_activity_ratio_bef_aft <- log(temp_period$activity_mean[temp_period$Before_After=="After"]/temp_period$activity_mean[temp_period$Before_After=="Before"])
                    temp_row$delta_depth_bef_aft <- temp_period$depth_mean[temp_period$Before_After=="After"] - temp_period$depth_mean[temp_period$Before_After=="Before"]
                    temp_row$delta_distance_bef_aft <-
                    abs(temp_period$distance_shore_mean[temp_period$Before_After=="After"] - temp_period$distance_shore_mean[temp_period$Before_After=="Before"])
                  }
      MHWs_comparison <- rbind(MHWs_comparison,temp_row)
    }
  }
}
MHWs_comparison <- merge(MHWs_comparison,MHWs_Eilat_Fix_OISST,by = "Serial")
MHWs_comparison <- MHWs_comparison %>% select(-Fish_IDs)#remove fish id
stat_tags_metadata_parrot <- tags_metadata_parrot %>% 
  select(fish_id,species) 
MHWs_comparison <- distinct(merge(MHWs_comparison,stat_tags_metadata_parrot,by = "fish_id"))
write.csv(MHWs_comparison,paste("Red Sea/Results/Individual Heatwaves/Eilat_MHWs_comparison_IUI__Fixbase_MHW_Stage_Avg_wide",Sys.Date(),".csv"))
```
## Graphs
```{r}
#activity
for (period in unique(MHW_Data$period_of_day)) {
 activity_plot <- ggplot(MHW_Data[MHW_Data$period_of_day==period,],aes(x=Before_After,y=activity))+
  geom_point(size=0.3,color="black",alpha=0.5)+
  geom_vline(xintercept = 0,color="red")+
  # scale_x_datetime(date_breaks = "7 days",date_labels = "%d/%m/%y")+
  geom_smooth(color="blue")+
  facet_wrap(~fish_id,ncol=1)+
   theme_bw()+
   theme(panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         panel.background = element_blank(),
         legend.position="none")
 depth_plot <- ggplot(MHW_Data[MHW_Data$period_of_day==period,],aes(x=Before_After,y=depth))+
  geom_point(size=0.3,color="black",alpha=0.5)+
  geom_vline(xintercept = 0,color="red")+
  # scale_x_datetime(date_breaks = "7 days",date_labels = "%d/%m/%y")+
  geom_smooth(color="darkgreen")+
  facet_wrap(~fish_id,ncol=1)+
   theme_bw()+
   theme(panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         panel.background = element_blank(),
         legend.position="none")
 longshore_plot <- ggplot(MHW_Data[MHW_Data$period_of_day==period,],aes(x=Before_After,y=distance_shore))+
  geom_point(size=0.3,color="black",alpha=0.5)+
  geom_vline(xintercept = 0,color="red")+
  # scale_x_datetime(date_breaks = "7 days",date_labels = "%d/%m/%y")+
  geom_smooth(color="gold")+
  facet_wrap(~fish_id,ncol=1)+
   theme_bw()+
   theme(panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         panel.background = element_blank(),
         legend.position="none")
 comibne_plot <- activity_plot+depth_plot+longshore_plot
ggsave(paste("Before_After_plot_",period,".png"),width = 4500,height = 10000,units = "px") 
}
 

```

### Combine fish and parrotfish
```{r}
MHWs_combined_data <- MHWs_fish_data %>% dplyr::select(Serial,fish_id,real_datetime,Before_After,activity,depth,distance_shore,intensity_mean,intensity_max,intensity_cumulative,duration,rate_onset,rate_decline,start_3,end_3,reliabaility.level.2,reliabaility.level.3)
MHWs_combined_data <- rbind(MHWs_combined_data,MHWs_parrotfish_data[,c(1:3,5:7,14,19:21,23,29:30,38:41)])
MHWs_combined_data <- MHWs_combined_data %>% 
  rename("reliabaility.level"= "reliabaility.level.2", "reliabaility.level.1" = "reliabaility.level.3")
MHWs_combined_data$Before_After <- factor(MHWs_combined_data$Before_After,levels = c("Before","MHW","After"))
```
### plot daily curves
```{r}
MHWs_combined_data$real_datetime <- ymd_hms(MHWs_combined_data$real_datetime)
MHWs_combined_data$TimeOfDay <- as.POSIXct(format(MHWs_combined_data$real_datetime,format = "%H:%M:%S"),format = "%H:%M:%S")
ggplot(MHWs_combined_data, aes(y=activity,x=TimeOfDay))+
  geom_smooth(aes(color = Before_After))+
  scale_x_datetime(breaks="3 hours",date_labels = "%H:%M")+
  theme_bw()

ggplot(MHWs_combined_data, aes(y=depth,x=TimeOfDay))+
  geom_smooth(aes(color = Before_After))+
  scale_x_datetime(breaks="3 hours",date_labels = "%H:%M")+
  scale_y_reverse()+
  theme_bw()+
  geom_point()

ggplot(MHWs_combined_data, aes(y=distance_shore,x=TimeOfDay))+
  geom_smooth(aes(color = Before_After))+
  scale_x_datetime(breaks="3 hours",date_labels = "%H:%M")+
  theme_bw()
```


## Check seasonality effect
```{r}
relevant_fish_id <- c("1212923","1212924", "1212925", "1168792", "1168793", "1255784", "1255785", "1255801", "1255802", "1255803", "1255804", "1255815", "1255814", "1255812", "1255811", "1255810", "1255807", "1255806", "1255800", "1255791", "1255792", "1273483", "1273484", "1273486", "1273489", "1273490", "19111342", "19111348", "19111351", "19111354", "19111357", "19111363", "19111369", "19111372", "1255805")
season_df <- combined_parrotfish_df %>% filter(fish_id %in% relevant_fish_id)

## Add temp data
OISST_data_red <- readRDS("Red Sea/Eilat climetology/OISST_SST_Red.RDS")
OISST_data_red <- OISST_data_red %>%
  filter(t %in% combined_parrotfish_df$date) %>% 
  select(t,temp) %>% 
  rename("date" = "t")
season_df <- merge(season_df,OISST_data_red,by = "date")

## Add species
species_metadata <- read.xlsx("Red Sea/Renanel All data/ID list fish.xlsx")
species_metadata <- species_metadata %>% rename("fish_id" = "id")
season_df <- season_df %>% select(-species)
season_df <- merge(season_df,species_metadata,by = "fish_id")
write.csv(season_df, "Red Sea/Results/seasonality.csv")


```

## Models loop
```{r}
# Define lists to store models and dredge results
models_list <- list()
dredge_results <- list()

# Unique Species values
species <- unique(MHWs_fish_data$species)

# Loop through each species
for (sp_i in species) {
  # Filter data for the current species
  data_species <- MHWs_fish_data %>% filter(species == sp_i)
  
  # Split the data for activity and depth, and remove rows with NAs
  data_species_depth <- data_species %>%
    filter(!is.na(log_depth)) %>% 
    select(log_depth,DecimalTimeOfDay,species,Before_After,duration,intensity_mean,intensity_mean_abs,rate_onset)
  data_species_activity <- data_species %>% filter(!is.na(activity)) %>% 
    select(activity,DecimalTimeOfDay,species,Before_After,duration,intensity_mean,intensity_mean_abs,rate_onset)
  
  # Check for sufficient data in both datasets
  if (nrow(data_species_depth) > 10 || nrow(data_species_activity) > 10) { # Adjust threshold as needed
    # Check if random effects are needed for depth and activity models
    include_fish_id_depth <- length(unique(data_species_depth$fish_id)) > 1
    include_serial_depth <- length(unique(data_species_depth$Serial)) > 1
    
    include_fish_id_activity <- length(unique(data_species_activity$fish_id)) > 1
    include_serial_activity <- length(unique(data_species_activity$Serial)) > 1
    
    # Build formulas dynamically
    formula_depth <- as.formula(
      paste(
        "log_depth ~ s(DecimalTimeOfDay, by = Before_After, bs = 'cc') + Before_After + intensity_mean + duration + rate_onset + intensity_mean_abs",
        if (include_fish_id_depth) "+ s(fish_id, bs = 're')" else "",
        if (include_serial_depth) "+ s(Serial, bs = 're')" else "",
        sep = " "
      )
    )
    formula_activity <- as.formula(
      paste(
        "activity ~ s(DecimalTimeOfDay, by = Before_After, bs = 'cc') + Before_After + intensity_mean + duration + rate_onset + intensity_mean_abs",
        if (include_fish_id_activity) "+ s(fish_id, bs = 're')" else "",
        if (include_serial_activity) "+ s(Serial, bs = 're')" else "",
        sep = " "
      )
    )
    
    # Fit depth model
    if (nrow(data_species_depth) > 10) {
      tryCatch({
        model_depth <- bam(
          formula_depth,
          data = data_species_depth, method = "REML", family = gaussian(),
          na.action = na.fail

        )
        models_list[[paste("Species", sp_i, "Depth", sep = "_")]] <- model_depth
        dredge_results[[paste("Species", sp_i, "Depth", sep = "_")]] <- dredge(model_depth)
      }, error = function(e) {
        message(paste("Error fitting depth model for Species:", sp_i, "-", e$message))
      })
    }
    
    # Fit activity model
    if (nrow(data_species_activity) > 10) {
      tryCatch({
        model_activity <- bam(
          formula_activity,
          data = data_species_activity, method = "REML", family = "tw",
          na.action = na.fail
        )
        models_list[[paste("Species", sp_i, "Activity", sep = "_")]] <- model_activity
        dredge_results[[paste("Species", sp_i, "Activity", sep = "_")]] <- dredge(model_activity)
      }, error = function(e) {
        message(paste("Error fitting activity model for Species:", sp_i, "-", e$message))
      })
    }
  } else {
    message(paste("Skipping Species:", sp_i, "- insufficient data"))
  }
}
# Save model list
saveRDS(models_list,"Red Sea/Results/Models_list_per_sp.RDS")

# Access individual models
names(models_list)  # Check model identifiers
model_summaries <- lapply(models_list, summary)

# Save diagnostics plots
for (name in names(models_list)) {
  model <- models_list[[name]]
  diagnostics_plot <- gratia::appraise(model) +
    ggtitle(paste("Model:", name)) # Diagnostics plot
  
  # Save the diagnostics plot as a PNG file
  file_name <- paste0("Diagnostics_", name, ".png")  # Generate file name
  ggsave(paste("Red Sea/Results/Models diagnostics/",file_name), plot = diagnostics_plot,
         width = 10, height = 6, dpi = 300)
  message(paste("Saved diagnostics plot for model:", name))

}


for (name in names(models_list)) {
  model <- models_list[[name]]
  plot_smooths(model, series = DecimalTimeOfDay, comparison = Before_After) +
  theme(legend.position = "top") + 
    ggtitle(paste("Model:", name)) +
    theme_bw()
}


predictions_list <- lapply(models_list, function(model) {
    # Check if the model is for depth or activity
    if (grepl("Depth", deparse(substitute(model)))) {
      # Prediction for depth model (log-transformed)
      log_pred <- predict(model, type = "response")  # Predicted on log scale
      # Back-transform the log-transformed predictions to the original scale
      exp_pred <- exp(log_pred)
      return(exp_pred)  # Return the back-transformed predictions
    } else  {
      # Prediction for activity model (on the scale used for the activity model)
      activity_pred <- predict(model, type = "response")
      return(activity_pred)  # Return activity predictions
    }
  })



```

